안녕하세요, 여러분! 지난 시간에는 대시보드를 구축하기 위한 전체적인 시스템 설계를 살펴봤는데요. 이제 실제 코드를 작성해 볼 차례입니다.

오늘은 프로젝트 전체에 걸쳐서 사용할 기본 기능을 살펴볼게요.

프로젝트의 작업 흐름을 다시 살펴보면,

1. 데이터 가져오기
2. ~~데이터 관리하기 (대사 누락)~~
3. 데이터 분석하기
4. 분석 결과를 대시보드에 보여주기

순서로 이루어졌습니다.

이 중에서 오늘은 **첫 번째 단계인 데이터 가져오기**에 필요한 KIS 패키지를 구현해보겠습니다.

한국투자증권(KIS) API와 소통하면서 주식 데이터를 가져오는 기능을 하고,

그 과정에서, API key와 같은 민감한 정보를 안전하게 관리하는 방법도 함께 살펴보겠습니다.

## KIS 모듈 구현하기

이전 강의에서 이미 KIS API를 통해 데이터를 가져와 봤었는데요, 이번에는 여러 번 안정적으로 사용할 수 있도록 체계적인 클래스로 만들어볼 거예요.

먼저 필요한 모듈을 임포트하고,

```python
import json
import time
import requests
import pandas as pd
from pathlib import Path
from datetime import datetime, timedelta
from sec_cik_mapper import StockMapper

# ✅ config_loader 불러오기
project_root = Path(__file__).resolve().parent.parent
sys.path.append(str(project_root))
from config.config_loader import config
```

클래스 이름과 init(이닛) 메서드를 선언합니다.

```python
class Kis:
    def __init__(self):
        # config_loader에서 kis 섹션 바로 불러오기
        self.config = config["kis"]  # kis 관련 설정만 추출

        self.base_url = self.config["url_base"]
        self.app_key = self.config["app_key"]
        self.app_secret = self.config["app_secret"]

        # 접근 토큰 발급
        self.access_token = self._get_access_token()
    ...

```

여기서 API 접근을 위한 정보를 가져오고, 접근 토큰을 발급받죠.

여기서 url, API 키, 비밀 키는 config_loader라는 모듈에서 가져오게 해놨는데, 이 파일의 기능을 좀더 자세히 살펴볼게요.

## config.yaml로 민감 정보 관리하기

API 요청이 있을 때마다 사용하는 API 키, 접근 토큰, 계좌번호 등은

매우 중요한 개인 정보입니다.

이런 민감한 정보는 코드에 직접 작성하기보다 별도의 설정 파일에서 관리하는 것이 안전해요.

이때 사용할 수 있는 파일 형식이 YAML입니다. JSON과 비슷하지만 좀 더 읽기 쉽게 데이터를 구조화하는 방식인데요,

- config_example.yaml

  ```yaml
  kis:
    url_base: '<https://openapi.koreainvestment.com:9443>' # 실전 계좌
    # url_base: "<https://openapivts.koreainvestment.com:29443>"  # 모의 투자 계좌 (사용 시 주석 해제)

    app_key: '...' # 한국투자증권에서 발급받은 앱 키
    app_secret: '...'
    customer_type: 'P' # 개인(P) / 법인(B)

    account:
      number: '...' # 계좌번호 앞 8자리
      product_code: '...' # 계좌상품코드 (계좌번호의 뒤 2자리)

  OPENAI_API_KEY: 'sk-proj...'
  DART_API_KEY: '...'
  ```

이렇게 모든 민감 정보를 한 파일에 모아두고, 이 정보에 접근하는 모듈은 따로 구현해 보안을 강화합니다.

그리고 이 정보들이 필요할 때는, 해당 모듈만 불러오면 되기 때문에 재사용성도 높일 수 있습니다.

- 코드: config_loader.py 전체

  ```python
  from openai import OpenAI
  from pathlib import Path
  import yaml

  # ✅ 경로 세팅 정확한지 확인
  project_root = Path(__file__).resolve().parent.parent
  # print(f"[DEBUG] project_root: {project_root}")

  config_path = project_root / "config" / "config.yaml"
  # ✅ config.yaml 파일 로드
  with open(config_path, "r", encoding="utf-8") as f:
      config = yaml.safe_load(f)

  OPENAI_API_KEY = config.get("OPENAI_API_KEY")
  DART_API_KEY = config.get("DART_API_KEY")

  openai_client = OpenAI(api_key=OPENAI_API_KEY)
  ```

이제 이 정보에 접근하려면, config 객체를 따로 불러와 사용해야 합니다.

```python
# ✅ config_loader 불러오기
project_root = Path(__file__).resolve().parent.parent
sys.path.append(str(project_root))
from config.config_loader import config
```

이 yaml 파일은 타인과 공유해서는 안되기 때문에, 깃허브를 비롯한 버전 관리 시스템에 올리지 않도록 주의해 주세요.

만약 공유해야 한다면, 민감한 정보는 반드시 가려야 한답니다.

여기서 직접적으로 눈에 보이는 기능 외에, 프로젝트를 장기간 안정적으로 운영하기 위한 기능도 필요해요.

KIS API를 사용하려면 `app_key, app_secret` 외에도 접근 토큰이 필요했는데요,

API를 한 번만 사용할 때는 괜찮지만, 여러 번 사용하려고 한다면,

이 접근 토큰이 발급 24시간 후에 만료되기 때문에

발급 시점을 적절히 관리해야 합니다.

- 코드: \_get_access_token() 메서드

  ```python
  def _get_access_token(self) -> str | None:
      """한국투자증권 API 접근 토큰을 세팅하는 메서드"""
      token_file = Path(__file__).parent / "token.json"

      # 기존 토큰 파일이 있는지 확인하고 읽기
      if token_file.exists():
          with open(token_file, "r", encoding="utf-8") as f:
              token_data = json.load(f)
              token = token_data.get("access_token")
              issued_time = token_data.get("issued_time")

              # 토큰 유효성 검사 (24시간 이내 발급)
              if token and issued_time:
                  issued_time = datetime.fromisoformat(issued_time)
                  if datetime.now() - issued_time < timedelta(hours=24):
                      # print(f"발급해 둔 토큰이 유효합니다.")
                      # print(f"토큰: {token[:10]}...")
                      # print(f"토큰 발급 시간: {issued_time}")
                      # print(f"토큰 발급 후 경과 시간: {datetime.now() - issued_time}")
                      return token

      # 토큰이 없거나 만료된 경우 새로운 토큰 발급 요청
      headers = {"content-type": "application/json"}
      body = {
          "grant_type": "client_credentials",
          "appkey": self.app_key,
          "appsecret": self.app_secret,
      }
      path = "oauth2/tokenP"
      url = f"{self.base_url}/{path}"

      # API 호출 제한 방지를 위한 지연
      time.sleep(0.1)
      res = requests.post(url, headers=headers, data=json.dumps(body))

      if res.status_code == 200:
          try:
              new_token = res.json().get("access_token")
              # 새로운 토큰과 발급 시간을 파일에 저장
              with open(token_file, "w", encoding="utf-8") as f:
                  json.dump(
                      {
                          "access_token": new_token,
                          "issued_time": datetime.now().isoformat(),
                      },
                      f,
                  )
              print(f"새로운 접근 토큰 발급: {new_token[:10]}...")
              print(f"토큰 발급 시간: {datetime.now().isoformat()}")
              return new_token
          except KeyError as e:
              print(f"접근 토큰 발급 중 오류 발생: {e}")
              print(res.json())
              return None
      else:
          print("접근 토큰 발급 실패. 응답 코드:", res.status_code)
          print("응답 내용:", res.json())
          return None
  ```

- token.json 예시
  ```json
  {
    "access_token": "eyJ...",
    "issued_time": "2025-03-20T..."
  }
  ```

이 메서드에서는

1. 먼저 `token.json` 파일이 있는지 확인합니다.
2. 파일이 있다면, 저장된 토큰이 아직 유효한지 확인합니다.
3. 토큰이 유효하면 그대로 사용하고, 파일이 없거나 토큰이 만료됐으면 새로운 토큰을 발급받습니다.
4. 새 토큰을 파일에 저장하고 반환합니다.

이렇게 하면 앱을 실행할 때마다 불필요하게 새 토큰을 발급받지 않아도 되며, 토큰이 만료되었을 때만 새로 발급받게 됩니다.

### 주요 API 호출 메서드 구현

이제 실제로 데이터를 가져오는 메서드들을 구현해 볼게요.

KIS API에서는 다양한 정보를 제공하는데,

하나의 메서드에서 한 가지 API만 접근하도록 구현합니다.

예를 들어서 국내주식기간별시세 정보는 get_period_chart() 메서드가 전담합니다.

해외주식의 기간별 시세는 get_overseas_period_chart()가 담당하고요.

![image.png](attachment:a635e97a-6712-4af9-a577-d3579a27e006:image.png)

```python
국내 당일 분봉 데이터 조회 (get_minute_chart_today())
국내 과거 분봉 데이터 조회 (get_minute_chart_past())
국내 기간별 주가 데이터 조회 (get_period_chart())
국내 주식 현재 정보 조회 (get_dom_detail())
국내 재무비율 정보 조회 (get_dom_financial_ratio())
해외 기간별 주가 데이터 조회 (get_overseas_period_chart())
해외 분봉 데이터 조회 (get_overseas_minute_chart())
해외 종목 상세 현재 조회 (get_overseas_detail())
해외 재무비율 현재 정보 조회 (get_ovs_financial_ratio())
```

이 기능들을 모두 kis 클래스에 속한 메서드로 구현하면,

프로젝트 다른 부분에서 필요한 기능만 뽑아서 쓸 수 있답니다.

예를 들어 차트 데이터 모듈에서 데이터 조회가 필요하면,

kis 모듈에 정의해 둔 함수만 호출하면 되는 거죠

### 1. **해외주식 기간별시세** 메서드

구체적인 내용은 해외 일봉 데이터 메서드만 대표로 살펴보겠습니다.

해외 일봉은 해외주식 기간별시세 API를 통해 가져올 수 있었죠?

![해외주식 기간별시세: header](attachment:1ff9eb72-d819-4e38-8527-6e4114b8c302:image.png)

해외주식 기간별시세: header

![해외주식 기간별시세: params](attachment:6efe7b75-820c-4890-8bb9-2c7f3c0f70ab:image.png)

해외주식 기간별시세: params

이 메서드는 특정 종목의 일봉, 주봉, 월봉 등 기간별 차트 데이터를 최대 100건씩 가져옵니다.

파라미터로는 거래소코드, 종목코드, 기간 구분, 조회 기준일자 등을 설정해야 합니다.

- 코드: get_overseas_period_chart()

  ```python
  def get_overseas_period_chart(
      self,
      stock_code: str,
      end_date: str,
      market_code: str = "NAS",
      period_code: int = 0,
  ) -> pd.DataFrame:  # 해외 일/주/월
      """해외 주식의 기간별 주가 데이터를 조회하는 메서드"""
      # API 엔드포인트 설정
      path = "/uapi/overseas-price/v1/quotations/dailyprice"
      url = f"{self.base_url}/{path}"

      # API 요청 헤더 설정 (인증 정보 포함)
      headers = {
          "content-type": "application/json",
          "authorization": f"Bearer {self.access_token}",
          "appkey": self.app_key,
          "appsecret": self.app_secret,
          "tr_id": "HHDFS76240000",  # 해외 주식 일봉(기간별 시세) 조회용 TR_ID
          "custtype": self.config["customer_type"],
      }

      # 일봉 조회 파라미터 설정
      params = {
          "AUTH": "",  # 기본 값 (Null)
          "EXCD": market_code,  # 거래소 코드 (예: 'NAS', 'NYS')
          "SYMB": stock_code,  # 종목 코드 (예: 'TSLA')
          "GUBN": period_code,  # 조회 구분 (0: 일, 1: 주, 2: 월)
          "BYMD": end_date,  # 조회 기준 일자: 한 번 호출에 이 날까지 100건 조회
          "MODP": "1",  # 수정주가 반영 여부 (0: 미반영, 1: 반영)
      }

      ...
  ```

따라서 이 메서드에서도 각 파라미터를 입력으로 받고, 이에 따라 가져온 데이터는 판다스 데이터프레임으로 반환합니다.

~~여기서 기간 코드(`GUBN`) 는 주로 일봉 차트를 사용할 예정이기 때문에 기본값을 '0'로 설정했고,~~

~~거래소 코드는 주로 관심이 있는 나스닥 코드를 기본값으로 두었어요.~~

헤더에는 config 파일에서 가져온 인증 정보와 tr_id(거래 ID)를 포함시켰습니다.

여기서 한 가지 중요하게 생각하셔야 할 부분을 말씀드리겠습니다.

이전 강의들에서는 주피터 노트북에서 실제로 되는지 한번씩 해보기 위한 코드를 작성했었죠?

그런데 이제는 구현해 둔 기능을 프로그램의 다른 부분들에서 사용하기 위한 코드를 작성하고 있습니다.

~~그래서 다른 부분에서~~ 사용하기 편하게 함수를 만드려면, ‘입력, 출력’을 어떻게 정리하는지가 핵심이 되는 것이죠.

그리고 나중에 이 함수를 사용할 때도 참고하기 편하도록 이렇게 주석으로 필요한 정보를 충분히 적어놓는 게 좋습니다!

특히, 요즘엔 커서나 깃허브 코파일럿 같은 AI 개발도구들을 많이 사용하죠?

프로젝트 규모가 커질 수록 AI가 필요한 구조를 파악하지 못할 가능성이 커지는데요,

이렇게 코드베이스 안에 설명을 상세히 적어놓으면 규모가 커져도 AI가 우리의 의도를 정확히 파악하고 작업을 하기 쉬워진답니다!

방금 작성한 메서드가 제대로 작동하는지, 한번 테스트해보겠습니다.

테스트를 위한 파라미터로 임의의 종목코드, 조회 시점, 주기를 입력해 넣었고,

반환된 데이터프레임을 csv파일로 저장했습니다.

![PYAIS #14_1 -00:00 (line 897-915)](attachment:adb5be9a-39fd-4e72-9437-cbb70ce2d501:image.png)

PYAIS #14_1 -00:00 (line 897-915)

![PYAIS #14_2 (사진입니다!)](attachment:714f2598-a075-4f5c-8869-dc115bf2cdf9:PYAIS_14_2.png)

PYAIS #14_2 (사진입니다!)

지정한 폴더 경로에 들어가면 100일치 일봉 데이터가 저장된 것을 확인할 수 있습니다.

이렇게 다른 메서드들도 API 문서를 참고해, 비슷하게 구현할 수 있습니다.

입출력에 필요한 변수를 잘 정의하는 걸 잊지 마세요!

예를 들어 방금 테스트한 메서드처럼 일봉, 분봉 차트 등을 가져올 때는 종목코드와 조회 기간, 거래소 정보가 함께 필요했습니다.

한편 get_dom_detail처럼 재무 지표를 가져오는 메서드라면, 조회하려는 기업의 종목 코드만 받으면 되겠죠.

- 코드: get_dom_detail()
  ```python
  def get_dom_detail(self, stock_code: str) -> dict:
      """국내 주식의 상세 정보를 조회하여
      주요 지표(PER, PBR, EPS, BPS)만 저장 후 반환
      """
      path = "/uapi/domestic-stock/v1/quotations/inquire-price"
      url = f"{self.base_url}/{path}"
      headers = {
          "content-type": "application/json",
          "authorization": f"Bearer {self.access_token}",
          "appkey": self.app_key,
          "appsecret": self.app_secret,
          "tr_id": "FHKST01010100",  # 국내 주식 현재가 시세 조회용 TR_ID
      }
      params = {
          "fid_etc_cls_code": "",
          "fid_cond_mrkt_div_code": "J",
          "fid_input_iscd": stock_code,
      }
      response = requests.get(url, headers=headers, params=params)
      data = response.json()
      df = pd.DataFrame(data["output"], index=[0])
      return df
  ```

## 마무리

오늘은 주식 데이터를 가져오기 위한 KIS 패키지의 기본 구조와 설정 파일 관리 방법에 대해 알아봤습니다.

이렇게 기능별로 분리해서 구현하면 코드를 더 체계적으로 관리할 수 있고, 여러 곳에서 재사용하기도 쉬워집니다.

다음 시간에는 KIS 패키지에서 가져온 데이터를 관리하는 데이터 관리 패키지를 구현해볼 예정입니다.

~~가져온 주식 데이터를 저장하고, 필요할 때 불러오며, 불필요한 데이터 조회가 너무 많이 발생하지 않게 관리해줄 거예요.~~

그럼 다음 시간에 만나요! 감사합니다.

---

### 1️⃣ KIS 패키지 설계

- 한국투자증권 API와 통신하여 주식 데이터를 가져오는 KIS 패키지를 체계적으로 구현합니다.
- 클래스 기반으로 설계하여 재사용성과 유지보수성을 높입니다.
- 각 API 요청을 독립적인 메서드로 분리하여 구현합니다.

```python
import json
import time
import sys
from pathlib import Path
from datetime import datetime, timedelta
import pandas as pd
import requests
from sec_cik_mapper import StockMapper

# ✅ config_loader 불러오기
project_root = Path(__file__).resolve().parent.parent
sys.path.append(str(project_root))
from config.config_loader import config

class Kis:
    def __init__(self):
        # config_loader에서 kis 섹션 바로 불러오기
        self.config = config["kis"]  # kis 관련 설정만 추출

        self.base_url = self.config["url_base"]
        self.app_key = self.config["app_key"]
        self.app_secret = self.config["app_secret"]

        # 접근 토큰 발급
        self.access_token = self._get_access_token()
    ...
```

### 2️⃣ config.yaml: 설정 정보 관리

- API 키, 계좌번호 등 민감한 정보는 별도의 설정 파일 config.yaml에서 관리합니다.
- YAML 형식을 사용하여 구조화된 설정 정보를 저장합니다.
- 설정 파일은 버전 관리 시스템(Git 등)에서 제외하여 보안을 강화합니다.

```yaml
# config.yaml
kis:
  url_base: 'https://openapivts.koreainvestment.com:9443'
  app_key: '...' # 한국투자증권에서 발급받은 앱 키
  app_secret: '...'
  customer_type: 'P' # 개인(P) / 법인(B)

  account:
    number: '...' # 계좌번호 앞 8자리
    product_code: '...' # 계좌상품코드 (계좌번호의 뒤 2자리)

OPENAI_API_KEY: 'sk-proj...'
DART_API_KEY: '...'
```

```python
# config_loader.py
from openai import OpenAI
from pathlib import Path
import yaml

# ✅ 경로 세팅
project_root = Path(__file__).resolve().parent.parent
config_path = project_root / "config" / "config.yaml"

# ✅ config.yaml 파일 로드
with open(config_path, "r", encoding="utf-8") as f:
    config = yaml.safe_load(f)

OPENAI_API_KEY = config.get("OPENAI_API_KEY")
DART_API_KEY = config.get("DART_API_KEY")

openai_client = OpenAI(api_key=OPENAI_API_KEY)
```

- 설정 정보에 접근하기 위해서는 config 객체를 따로 불러와 사용합니다.

```python
# ✅ config_loader 불러오기
project_root = Path(__file__).resolve().parent.parent
sys.path.append(str(project_root))
from config.config_loader import config
```

- 접근 토큰은 `_get_access_token()` 메서드로 관리합니다.

```python
def _get_access_token(self) -> str | None:
    """한국투자증권 API 접근 토큰을 세팅하는 메서드"""
    token_file = Path(__file__).parent / "token.json"

    # 기존 토큰 파일이 있는지 확인하고 읽기
    if token_file.exists():
        with open(token_file, "r", encoding="utf-8") as f:
            token_data = json.load(f)
            token = token_data.get("access_token")
            issued_time = token_data.get("issued_time")

            # 토큰 유효성 검사 (24시간 이내 발급)
            if token and issued_time:
                issued_time = datetime.fromisoformat(issued_time)
                if datetime.now() - issued_time < timedelta(hours=24):
                    return token

    # 토큰이 없거나 만료된 경우 새로운 토큰 발급 요청
    headers = {"content-type": "application/json"}
    body = {
        "grant_type": "client_credentials",
        "appkey": self.app_key,
        "appsecret": self.app_secret,
    }
    path = "oauth2/tokenP"
    url = f"{self.base_url}/{path}"

    # API 호출 제한 방지를 위한 지연
    time.sleep(0.1)
    res = requests.post(url, headers=headers, data=json.dumps(body))

    if res.status_code == 200:
        try:
            new_token = res.json().get("access_token")
            # 새로운 토큰과 발급 시간을 파일에 저장
            with open(token_file, "w", encoding="utf-8") as f:
                json.dump(
                    {
                        "access_token": new_token,
                        "issued_time": datetime.now().isoformat(),
                    },
                    f,
                )
            print(f"새로운 접근 토큰 발급: {new_token[:10]}...")
            print(f"토큰 발급 시간: {datetime.now().isoformat()}")
            return new_token
        except KeyError as e:
            print(f"접근 토큰 발급 중 오류 발생: {e}")
            print(res.json())
            return None
    else:
        print("접근 토큰 발급 실패. 응답 코드:", res.status_code)
        print("응답 내용:", res.json())
        return None
```

- 발급한 토큰을 token.json에서 확인합니다.

```json
{
  "access_token": "eyJ...",
  "issued_time": "2025-03-20T..."
}
```

<aside>
⚠️

**여기서 잠깐!**

- 설정 파일에 포함된 API 키, 계좌번호 등은 절대로 Github 등에 공개되지 않도록 주의해야 합니다.
  - git을 사용하는 경우 .gitignore 파일에 config.yaml을 추가하여 실수로 커밋되지 않도록 해야 합니다.
- 프로젝트를 꼭 공유해야 할 때는 민감 정보가 제거된 예시 파일(config_example.yaml)을 대신 제공하는 것이 좋습니다.
</aside>

### 3️⃣ API 호출 메서드 구현

- 다양한 API 요청을 개별 메서드로 분리하여 구현합니다.
  - 함수와 클래스로 코드를 구조화하고, 상세한 주석을 담아 재사용성과 유지보수성을 높입니다.
    - 코드의 기능과 작성 의도를 담은 주석은 다른 개발자 또는 미래의 자신이 코드를 이해하는 데 도움을 줍니다.
    - 더 나아가 AI 개발 도구(예: GitHub Copilot)가 코드를 더 잘 이해하고 도움을 줄 수 있게 합니다.
- 해외 주식 일봉 데이터를 가져오는 메서드를 예시로 살펴봅니다.
- API 문서를 확인합니다.

![해외주식 기간별시세: header](attachment:1ff9eb72-d819-4e38-8527-6e4114b8c302:image.png)

해외주식 기간별시세: header

![해외주식 기간별시세: params](attachment:6efe7b75-820c-4890-8bb9-2c7f3c0f70ab:image.png)

해외주식 기간별시세: params

- 거래소코드(EXCD), 종목코드(SYMB), 조회기간 구분(GUBN), 조회 기준일자(BYMD)를 파라미터로 받아 최대 100건의 주가 데이터를 조회합니다.

```python
# 해외주식 기간별시세 조회
def get_overseas_period_chart(
    self,
    stock_code: str,
    end_date: str,
    market_code: str = "NAS",
    period_code: int = 0,
) -> pd.DataFrame:  # 해외 일/주/월
    # API 엔드포인트 설정
    path = "/uapi/overseas-price/v1/quotations/dailyprice"
    url = f"{self.base_url}/{path}"

    # API 요청 헤더 설정 (인증 정보 포함)
    headers = {
        "content-type": "application/json",
        "authorization": f"Bearer {self.access_token}",
        "appkey": self.app_key,
        "appsecret": self.app_secret,
        "tr_id": "HHDFS76240000",  # 해외 주식 일봉(기간별 시세) 조회용 TR_ID
        "custtype": self.config["customer_type"],
    }

    # 일봉 조회 파라미터 설정
    params = {
        "AUTH": "",  # 기본 값 (Null)
        "EXCD": market_code,  # 거래소 코드 (예: 'NAS', 'NYS')
        "SYMB": stock_code,  # 종목 코드 (예: 'TSLA')
        "GUBN": period_code,  # 조회 구분 (0: 일, 1: 주, 2: 월)
        "BYMD": end_date,  # 조회 기준 일자: 한 번 호출에 이 날까지 100건 조회
        "MODP": "1",  # 수정주가 반영 여부 (0: 미반영, 1: 반영)
    }

    ...
```

<aside>
➕

**KIS 패키지 주요 메서드 정리**

- 국내 당일 분봉 데이터 조회: get_minute_chart_today()
- 국내 과거 분봉 데이터 조회: get_minute_chart_past()
- 국내 기간별 주가 데이터 조회: get_period_chart()
- 국내 주식 현재가 시세 조회: get_dom_detail()
- 국내 재무비율 정보 조회: get_dom_financial_ratio()
- 해외 기간별 주가 데이터 조회: get_overseas_period_chart()
- 해외 분봉 데이터 조회: get_overseas_minute_chart()
- 해외 종목 상세 현재 조회: get_overseas_detail()
</aside>

### 4️⃣ 테스트 및 데이터 저장

- 구현한 메서드가 제대로 작동하는지 테스트합니다.
  - 가져온 데이터는 파일로 저장해 확인합니다.

```python
# 차트 데이터 저장 테스트
if __name__ == "__main__":
    kis = Kis()

    query_start = datetime(2024, 1, 1) # 조회 시작 시점
    fetch_end = datetime.now() # 조회 종료 시점
    PERIOD_CODE = 0 # 조회 주기: 일봉

    ovs_chart = kis.get_overseas_period_chart(
        "NVDA",
        fetch_end.strftime("%Y%M%d"),
        period_code=PERIOD_CODE
    )

    # csv로 차트 데이터 저장
    with open(Path(__file__).resolve().parent / 'NVDA_chart.csv', 'w', encoding='utf-8') as f:
        ovs_chart.to_csv(f)

    print(f"데이터 저장 완료: {len(ovs_chart)}건")
```

![PYAIS #14_2.png](attachment:714f2598-a075-4f5c-8869-dc115bf2cdf9:PYAIS_14_2.png)

- 다른 메서드도 API 문서를 바탕으로 입출력과 로직을 구현합니다.
  - 예를 들어, `get_dom_detail()`은 국내 기업의 종목코드를 입력받아 주요 재무지표를 반환합니다.

```python
def get_dom_detail(self, stock_code: str) -> dict:
    """
    국내 주식의 상세 정보를 조회하여
    주요 재무지표(PER, PBR, EPS, BPS)만 저장 후 반환
    """
    path = "/uapi/domestic-stock/v1/quotations/inquire-price"
    url = f"{self.base_url}/{path}"
    headers =
        "content-type": "application/json",
        "authorization": f"Bearer {self.access_token}",
        "appkey": self.app_key,
        "appsecret": self.app_secret,
        "tr_id": "FHKST01010100",  # 국내 주식 현재가 시세 조회용 TR_ID
    }
    params = {
        "fid_etc_cls_code": "",
        "fid_cond_mrkt_div_code": "J",
        "fid_input_iscd": stock_code,
    }
    response = requests.get(url, headers=headers, params=params)
    data = response.json()
    df = pd.DataFrame(data["output"], index=[0])
    return df
```
