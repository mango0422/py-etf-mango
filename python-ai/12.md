# 12강: 적금식 자동 매수 시스템 만들기 (Scheduling 활용하기)

안녕하세요, 여러분!

지난 시간에는 한국투자증권 API를 이용해서 주식을 주문하는 방법을 배웠습니다.

오늘은 한 발 더 나아가, 적립식 투자 방식으로 주식을 자동 매수하는 시스템을 만들어볼 겁니다.

---

## 적립식 투자란?

우선, 적립식 투자가 무엇인지 간단히 정리하고 갈게요.

적립식 투자는 은행에 매달 일정 금액을 넣는 적금처럼, 주식에 일정 금액을 정기적으로 투자하는 방식입니다.

이 방식은 큰 돈을 한 번에 투자하는 것이 아니라, 시간을 두고 조금씩 투자하기 때문에 시장이 상승하거나 하락하는 타이밍에 대한 고민을 덜어줍니다.

이 방법은 다음과 같은 장점이 있습니다:

- 평균 매수가를 안정화해서 시장 타이밍 리스크를 줄여줍니다.
- 심리적 부담을 덜어줘 투자 스트레스를 줄여주고요,
- 장기 투자를 끊기지 않고 하기 좋은 방식입니다.

하지만, 매번 수동으로 투자하기는 번거롭겠죠? 그래서 오늘은 이 과정을 자동화해서, 일정한 날짜와 시간에 자동으로 주식을 매수하는 프로그램을 만들어보겠습니다.

---

## 필요한 라이브러리 설치와 임포트

자동 매수를 위해서는 `schedule` 라이브러리가 필요합니다.

```bash
pip install schedule
```

만약, schedule 라이브러리가 설치되어 있지 않다면 설치해주세요!

```python
from datetime import datetime
import requests
import json
import time
import schedule  # 정기적으로 작업을 실행해주는 라이브러리
import os
from dotenv import load_dotenv
```

## 환경 변수와 접근 토큰 발급하기

기본적으로 필요한 라이브러리, 환경 설정, 액세스 토큰 세팅을 해주세요.

```python
load_dotenv()

KIS_URL_BASE = os.getenv("KIS_URL_BASE")
KIS_APP_KEY = os.getenv("KIS_APP_KEY")
KIS_APP_SECRET = os.getenv("KIS_APP_SECRET")

CANO = os.getenv("CANO")
ACNT_PRDT_CD = os.getenv("ACNT_PRDT_CD")
```

```python
def get_access_token():
    headers = {"content-type": "application/json"}
    body = {
        "grant_type": "client_credentials",
        "appkey": KIS_APP_KEY,
        "appsecret": KIS_APP_SECRET
    }
    URL = f"{KIS_URL_BASE}/oauth2/tokenP"
    res = requests.post(URL, headers=headers, data=json.dumps(body))
    return res.json().get("access_token")
```

---

## 주식 정보 조회 및 주문 함수

지난 시간에 작성한 함수들도 사용해주겠습니다.

```python
def get_current_price(access_token, market_code, product_code):
    url = f"{KIS_URL_BASE}/uapi/overseas-price/v1/quotations/price"
    headers = {
        "content-type": "application/json; charset=utf-8",
        "authorization": f"Bearer {access_token}",
        "appkey": KIS_APP_KEY,
        "appsecret": KIS_APP_SECRET,
        "tr_id": "HHDFS00000300",
        "custtype": "P"
    }
    params = {"EXCD": market_code, "SYMB": product_code}
    time.sleep(0.1)
    response = requests.get(url, headers=headers, params=params)
    data = response.json()
    return data['output']['last']
```

```python
def order_ovs_stock(access_token, market_code, product_code, quantity, price, is_buy=True):
    url = f"{KIS_URL_BASE}/uapi/overseas-stock/v1/trading/order"
    tr_id = "VTTT1002U" if is_buy else "VTTT1001U"
    headers = {
        "content-type": "application/json",
        "authorization": f"Bearer {access_token}",
        "appkey": KIS_APP_KEY,
        "appsecret": KIS_APP_SECRET,
        "tr_id": tr_id,
        "custtype": "P"
    }
    payload = {
        "CANO": CANO,
        "ACNT_PRDT_CD": ACNT_PRDT_CD,
        "OVRS_EXCG_CD": market_code,
        "PDNO": product_code,
        "ORD_QTY": quantity,
        "OVRS_ORD_UNPR": price,
        "ORD_SVR_DVSN_CD": "0",
        "ORD_DVSN": "00"
    }
    time.sleep(0.1)
    response = requests.post(url, headers=headers, json=payload)
    return response.json()
```

~~이전 강의와 달라진 점은 `access_token`을 함수 내부에서 발급받지 않고, 매개변수로 받도록 했다는 점이에요. 이렇게 하면 API를 통해 발급받은 access_token이 만료되더라도 자동화 함수에서 새로운 토큰을 발급받아 사용할 수 있습니다.~~

---

## 정기 매수 자동화 함수 작성하기

이제 지금까지 만든 함수를 결합해서, 정해진 시간에 자동으로 실행할 함수를 만들어 보겠습니다.

```python
def scheduled_order_stock():
    access_token = get_access_token()
    market_code = "NAS"  # 나스닥 거래소
    product_code = "AAPL"  # 애플 주식

    cur_price = get_current_price(access_token, market_code,
                                  product_code)
    cur_time = datetime.now().strftime('%H:%M:%S')
    print(f"{cur_time} - 애플 현재 가격: ${cur_price}")

    result = order_ovs_stock(
        access_token,
        market_code,
        product_code,
        quantity="1",
        price=cur_price,
        is_buy=True
    )

    print(f"{cur_time} - 주문 결과: {result}")
```

자동화 코드가 돌아갈 때, 실행 주기가 길다면 access_token이 만료될 수 있어요.

그래서 함수 안에서 접근 토큰부터 발급 받도록 만들겠습니다!

그리고 이전 강의와 동일하게 나스닥 거래소에서 애플 주식을 매수하는 것으로 진행해보겠습니다!

~~그래서 `marker_code`에는 `NAS`, `product_code`에는 `AAPL`을 넣어주겠습니다.~~

또한, 이전 강의와 마찬가지로 주문하자마자 체결되도록 하기 위해 현재 시세로 주문을 넣도록 할게요.

그래서 주식의 현재 가격을 불러오는 함수를 호출하고, 주식 주문 함수를 호출하겠습니다.

마지막으로, 지금까지 작성한 코드가 실제로 잘 동작하는지 확인하기 위해서 결과를 시간과 함께 출력해보겠습니다.

이때 시간 표시를 편리하게 하기 위해서 파이썬의 `datetime` (데이트 타임) 라이브러리를 활용했습니다.

`datetime.now()`를 사용해 현재 시간을 가져오고, `strftime()` (스트링포멧타임) 메서드로 깔끔하게 출력할 수 있습니다.

이렇게 작성하면 정기적으로 매수할 때 사용되는 함수가 완성이 되었습니다.

---

## 스케줄러 설정 및 실행하기

이제 마지막으로 이 작업이 정기적으로 수행될 수 있도록 `schedule` 라이브러리를 이용해 시간을 지정해주면 됩니다.
예를 들어, 미국 정규장이 시작하는, 한국 시간 밤 11시 30분에 맞춰 자동으로 주식을 1주씩 매수하도록 설정할 수 있겠죠?

스케쥴 라이브러리 사용법을 잠시 살펴볼게요.

다음과 같이 작성해주시면,

1분마다, do 안의 함수를 실행하도록 설정하는 겁니다.

이렇게 쓰면, 월요일 10시마다 정해진 함수를 실행합니다.

또 이렇게 하면, 매일 09시 30분마다 정해진 함수를 실행하게 할 수 있습니다.

```python
# 활용법 예시: (코드 녹화 x)
schedule.every(1).minutes.do(scheduled_order_stock)
schedule.every().monday.at("10:00").do(scheduled_order_stock)
schedule.every().day.at("09:30").do(scheduled_order_stock)
```

```python
schedule.every().day.at("09:30").do(scheduled_order_stock)

print("자동 주식 매수 시스템을 시작합니다. 종료하려면 Ctrl+C를 누르세요.")
while True:
    schedule.run_pending()
    time.sleep(1)
```

이렇게 적절히 조합하면 원하는 시점에 자동으로 작업을 실행하는 시스템을 쉽게 만들 수 있습니다.

잘 작동하는지 테스트를 위해 우선 1분마다 실행되도록 해보겠습니다.

또한, 지금 설정한 스케줄링 작업이 자동으로 실행되려면 프로그램이 종료되어선 안되겠죠?

그래서 무한 반복문으로 프로그램이 종료되지 않도록 하고,

매 반복마다 1초 기다리면서 과부화 되는 걸 방지해 줄게요.

schedule.run_pending()을 호출하면 등록된 작업 중 실행 시점이 된 작업이 있는지 확인하고,

정해진 시점에 도달한 작업은 실제로 실행합니다.

이렇게 하면 프로그램이 종료되지 않고, 스케줄링된 작업을 안정적으로 실행할 수 있게 됩니다.

```jsx
12:41:18 - 애플 현재가: 45850
12:41:18 - 주문 결과: {'rt_cd': '0', 'msg_cd': '40600000', 'msg1': '모의투자 매수주문이 완료 되었습니다.', 'output': {'KRX_FWDG_ORD_ORGNO': '00950', 'ODNO': '0000010358', 'ORD_TMD': '025323'}}
12:42:18 - 애플 현재가: 45850
12:42:18 - 주문 결과: {'rt_cd': '0', 'msg_cd': '40600000', 'msg1': '모의투자 매수주문이 완료 되었습니다.', 'output': {'KRX_FWDG_ORD_ORGNO': '00950', 'ODNO': '0000010358', 'ORD_TMD': '025323'}}
12:43:18 - 애플 현재가: 45850
12:43:18 - 주문 결과: {'rt_cd': '0', 'msg_cd': '40600000', 'msg1': '모의투자 매수주문이 완료 되었습니다.', 'output': {'KRX_FWDG_ORD_ORGNO': '00950', 'ODNO': '0000010358', 'ORD_TMD': '025323'}}
```

[ScreenRecording_04-10-2025 23-44-45_1.MP4](attachment:311ba2f7-2f35-4368-98b7-b61a561ecb34:ScreenRecording_04-10-2025_23-44-45_1.mp4)

실행해보면, 1분에 한 번씩 주문이 잘 실행되는 것을 확인할 수 있네요!

여러분이 원하는 대로 주기 세팅 값만 조절하면, 각자 의도한 시점에 매매를 진행할 수 있겠죠?

---

## 정리

오늘은 적립식 자동 매수 시스템을 구현해보았습니다.
다음 강의에서는 이때까지 들은 강의 내용을 모두 총합하여 완결된 전체 시스템을 구현해보는 프로젝트를 해보겠습니다.
감사합니다!

[화면 기록 2025-04-10 오후 11.36.06.mov](attachment:70b42df6-3896-46a3-a05c-e18f30ce24ee:화면_기록_2025-04-10_오후_11.36.06.mov)

고객 데이터를 분석해서 상위 20% 고객이 전체 매출의 몇 %를 차지하는지 파악하고 싶어.

핵심 고객층의 기여도를 시각적으로 보여주고

---

### **1️⃣ 적립식 투자의 개념**

- 적립식 투자는 금융 상품에 일정 금액을 정기적으로 투자하는 방식입니다.
  - 큰 금액을 한 번에 투자하는 대신 시간을 두고 조금씩 투자합니다.
- 적립식 투자의 장점은 다음과 같습니다.
  - 평균 매수가를 안정화하여 시장 타이밍 리스크를 줄여줍니다.
  - 심리적 부담을 덜어 투자 스트레스를 감소시킵니다.
  - 장기 투자 습관을 유지하도록 도와줍니다.

### **2️⃣ 자동화를 위한 환경 설정**

- 적립식 투자 자동화를 위해 schedule 라이브러리를 활용합니다.

```bash
pip install schedule
```

```python
# 그 외 필요한 라이브러리 임포트
from datetime import datetime
import requests
import json
import time
import os
from dotenv import load_dotenv

import schedule
```

- 환경 변수와 접근 토큰을 설정합니다.

```python
# 환경 변수 로드
load_dotenv()

KIS_URL_BASE = os.getenv("KIS_URL_BASE")
KIS_APP_KEY = os.getenv("KIS_APP_KEY")
KIS_APP_SECRET = os.getenv("KIS_APP_SECRET")

CANO = os.getenv("CANO")
ACNT_PRDT_CD = os.getenv("ACNT_PRDT_CD")

# 접근 토큰 발급 함수
def get_access_token():
    headers = {"content-type": "application/json"}
    body = {
        "grant_type": "client_credentials",
        "appkey": KIS_APP_KEY,
        "appsecret": KIS_APP_SECRET
    }
    URL = f"{KIS_URL_BASE}/oauth2/tokenP"
    res = requests.post(URL, headers=headers, data=json.dumps(body))
    return res.json().get("access_token")
```

### **3️⃣ 주식 정보 조회 및 주문 함수**

- 지난 강의에서 작성한 함수를 활용합니다.
  - 현재가로 주문을 넣기 위해 get_current_price 함수를 활용합니다.
  - order_ovs_stock으로 해외주식 주문 API와 소통합니다.

```python
# 해외주식 현재가 조회 함수
def get_current_price(access_token, market_code, product_code):
    url = f"{KIS_URL_BASE}/uapi/overseas-price/v1/quotations/price"
    headers = {
        "content-type": "application/json; charset=utf-8",
        "authorization": f"Bearer {access_token}",
        "appkey": KIS_APP_KEY,
        "appsecret": KIS_APP_SECRET,
        "tr_id": "HHDFS00000300",
        "custtype": "P"
    }
    params = {"EXCD": market_code, "SYMB": product_code}
    time.sleep(0.1)
    response = requests.get(url, headers=headers, params=params)
    data = response.json()
    return data['output']['last']

# 해외주식 주문 함수
def order_ovs_stock(access_token, market_code, product_code, quantity, price, is_buy=True):
    url = f"{KIS_URL_BASE}/uapi/overseas-stock/v1/trading/order"
    tr_id = "VTTT1002U" if is_buy else "VTTT1001U"
    headers = {
        "content-type": "application/json",
        "authorization": f"Bearer {access_token}",
        "appkey": KIS_APP_KEY,
        "appsecret": KIS_APP_SECRET,
        "tr_id": tr_id,
        "custtype": "P"
    }
    payload = {
        "CANO": CANO,
        "ACNT_PRDT_CD": ACNT_PRDT_CD,
        "OVRS_EXCG_CD": market_code,
        "PDNO": product_code,
        "ORD_QTY": quantity,
        "OVRS_ORD_UNPR": price,
        "ORD_SVR_DVSN_CD": "0",
        "ORD_DVSN": "00"
    }
    time.sleep(0.1)
    response = requests.post(url, headers=headers, json=payload)
    return response.json()
```

### **4️⃣ 정기 매수 자동화 구현**

- 정기 매수를 위한 함수를 구현합니다.

```python
# 애플 주식 정기 매수
def scheduled_order_stock():
    access_token = get_access_token()
    market_code = "NAS"  # 나스닥 거래소
    product_code = "AAPL"  # 애플 주식

    cur_price = get_current_price(access_token, market_code,
                                  product_code)
    cur_time = datetime.now().strftime('%H:%M:%S')
    print(f"{cur_time} - 애플 현재 가격: ${cur_price}")

    result = order_ovs_stock(
        access_token,
        market_code,
        product_code,
        quantity="1",
        price=cur_price,
        is_buy=True
    )

    print(f"{cur_time} - 주문 결과: {result}")
```

- 정기 매수 함수를 매일 실행하도록 스케줄러를 설정하고 실행합니다.

```python
# 매일 오전 9시 30분에 주문 실행
schedule.every().day.at("09:30").do(scheduled_order_stock)

# 또는 테스트를 위해 1분마다 실행# schedule.every(1).minutes.do(scheduled_order_stock)

print("자동 주식 매수 시스템을 시작합니다. 종료하려면 Ctrl+C를 누르세요.")
while True:
    schedule.run_pending()
    time.sleep(1)
```

- 결과를 확인합니다.

```json
12:41:18 - 애플 현재가: 45850
12:41:18 - 주문 결과: {'rt_cd': '0', 'msg_cd': '40600000', 'msg1': '모의투자 매수주문이 완료 되었습니다.', 'output': {'KRX_FWDG_ORD_ORGNO': '00950', 'ODNO': '0000010358', 'ORD_TMD': '025323'}}
12:42:18 - 애플 현재가: 45850
12:42:18 - 주문 결과: {'rt_cd': '0', 'msg_cd': '40600000', 'msg1': '모의투자 매수주문이 완료 되었습니다.', 'output': {'KRX_FWDG_ORD_ORGNO': '00950', 'ODNO': '0000010358', 'ORD_TMD': '025323'}}
12:43:18 - 애플 현재가: 45850
12:43:18 - 주문 결과: {'rt_cd': '0', 'msg_cd': '40600000', 'msg1': '모의투자 매수주문이 완료 되었습니다.', 'output': {'KRX_FWDG_ORD_ORGNO': '00950', 'ODNO': '0000010358', 'ORD_TMD': '025323'}}
```

<aside>
➕

**schedule 라이브러리 활용 예시**

- schedule은 특정 시각에 파이썬 스크립트를 자동실행하고, 시점을 관리할 수 있게 해주는 라이브러리입니다.

| 특정 시각에 작업 실행        | `schedule.every().day.at("10:30").do(함수명)`    |
| ---------------------------- | ------------------------------------------------ |
| 특정 요일에 작업 실행        | `schedule.every().monday.do(함수명)`             |
| 특정 요일과 시각에 작업 실행 | `schedule.every().monday.at("10:30").do(함수명)` |
| 일정 간격으로 작업 실행      | `schedule.every(10).minutes.do(함수명)`          |

</aside>

<aside>
⚠️

**여기서 잠깐!**

- 서버에서 자동화 프로그램을 장시간 실행할 때는 다음 사항을 고려하는 것이 좋습니다. - 오류 발생 시 자동 복구 방안 마련하기 - 로그 남기기(파일이나 데이터베이스에 기록) - nohup 또는 systemd와 같은 도구로 백그라운드 실행 설정하기
</aside>
