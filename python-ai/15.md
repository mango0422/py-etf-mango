안녕하세요, 여러분!

지난 시간에는 한국투자증권 API와 소통하기 위한 KIS 패키지를 구현해보았는데요.

오늘은 그 모듈을 통해 가져온 데이터를 효율적으로 관리하는 데이터 관리 패키지에 대해 알아보겠습니다.

우선, 왜 굳이 따로 패키지를 만들어 데이터 관리를 수행하는지 알아봅시다.

우리 대시보드에서는:

1. 여러 종목의 차트 데이터를 조회할 수 있어야 하고,
2. 기간별로 데이터를 보여줄 수 있어야 하며,
3. 실시간으로 최신 정보를 반영해야 합니다.

하지만 매번 API를 호출하여 모든 데이터를 새로 가져오는 것은 비효율적입니다.

API 호출 횟수가 많아지면 서버에 부담이 되고, 데이터 중복이 발생하기도 쉽죠.

따라서 효율적인 데이터 관리 시스템이 필요합니다.

이 시스템의 구체적인 역할을 알아보기 위해, 우리 프로젝트의 디렉토리 구조를 다시 한 번 보겠습니다.

```
project
├── kis
│   └── kis.py
├── data
│   ├── charts
│   ├── financials
│   └── news
├── data_loader
│   ├── __init__.py:
│   ├── chart.py
│   ├── financials.py
│   ├── news.py
│   └── settings.json: 데이터 가져올 주기 설정
├── analysis <- 다음 강의에서 설명
│   ├── __init__.py
│   ├── ...
├── config
│   ├── config_loader.py: config.yaml 파일 로드
│   └── config.yaml
├── report
│   ├── ...
└── app.py
```

지난 시간에는 이 중에서 [kis.py](http://kis.py) 파일에 KIS 클래스를 만들었는데,

API에 직접 접근하는 기능을 모두 담고 있었습니다.

이제 루트 폴더에 data_loader 폴더를 새로 만들고,

그 안에서 차트 데이터(chart.py), 재무 데이터(financials.py), 뉴스 데이터(news.py)를 가져오는 기능을 3개의 모듈로 나누고,

각각에 ChartFetcher, FinancialsFetcher, NewsFetcher를 클래스로 구현합니다.

이 모듈 3개를 묶은 것이 우리의 데이터 로더 패키지입니다.

우리가 pandas 라이브러리나, openai API를 사용할 때는

이렇게 라이브러리 전체나, 그 안에서 필요한 세부 모듈을 임포트해서 사용했었죠.

- 코드: 외부 라이브러리 import 예시

  ```python
  import pandas
  from openai import OpenAI

  ...
  ```

이것처럼, 우리가 새로 작성한 모듈도 프로젝트의 다른 곳에서 가져와 사용할 수 있습니다.

- 코드: 데이터 모듈 import 예시
  ```python
  from analysis import FundamentalAnalysis, TechnicalAnalysis, NewsAnalysis
  from data_loader.financials import FinancialsFetcher
  ```

이때 각각의 모듈을 한 번에 임포트 가능한 하나의 패키지로 만들기 위해서는

상위 폴더에 **init**.py 파일을 추가해 주면 됩니다.

이 파일은 비워두어도 되지만,

다음과 같이 개별 패키지 내부의 어떤 모듈을 외부에서 사용할 수 있게 할지 명시해줄 수도 있습니다.

```python
# data_loader 패키지 초기화 파일
# 다른 모듈에서 import 할 수 있도록 필요한 클래스들을 노출시킵니다

# 필요한 모듈들을 import
from data_loader.financials import FinancialsFetcher
from data_loader.chart import ChartFetcher
from data_loader.news import NewsFetcher

# 패키지에서 외부로 노출할 클래스/함수 정의
__all__ = ['FinancialsFetcher', 'ChartFetcher', 'NewsFetcher']
```

이제 각 모듈에서 필요한 핵심 기능에 대해 알아보겠습니다.

## 1. 데이터 조회 시점 관리

데이터 조회를 실제로 하기 전에 필요한 기능은 데이터 조회 시점 관리입니다.

어느 시점의 데이터부터 가져올지, 얼마나 자주 데이터를 가져올지 결정하는거죠.

이를 위해 `settings.json` 파일을 만들어 각 데이터 유형별로 수집 기간과 주기를 설정합니다.

- settings.json
  ```json
  {
    "chart_collection": {
      "min": {
        "days_ago": 7,
        "description": "분봉 데이터는 7일 전부터 수집"
      },
      "daily": {
        "days_ago": 1825,
        "description": "일봉 데이터는 5년 전부터 수집"
      },
      "weekly": {
        "days_ago": 3650,
        "description": "주봉 데이터는 10년 전부터 수집"
      }
    },
    "news_collection": {
      "hours_threshold": 1
    }
  }
  ```

이 설정 파일을 보면, 분봉 데이터는 1주일 전부터, 일봉 데이터는 5년 전부터, 주봉 데이터는 10년 전부터 수집하도록 지정했습니다.

뉴스 데이터는 마지막으로 가져온지 1시간이 지났으면 갱신하도록 설정했습니다.

5년, 10년이라는 기간이 꽤 길다고 느끼실 수 있는데요,

여러 번 조금씩 데이터를 가져오는 것보다,

처음 한 종목을 조회할 때 장기간의 데이터를 미리 저장해놓고,

다음에 같은 종목의 조회 요청이 왔을 때

지금 있는 데이터에서 추가로 필요한 최신 정보만 조회해서 채워두는 식으로 구현하는 편이 장기적으로 봤을 때 효율적이기 때문입니다.

이제, 이 설정값을 기준으로 ‘어떻게 데이터 수집 시점을 관리할 수 있는지’ 알아봅시다.

- 코드: ChartFetcher 클래스

  ```python
  class ChartFetcher:
      """차트 데이터를 관리하는 클래스"""
      def __init__(self):
          """
          설정 초기화 및 데이터 디렉토리 구성
          """
          # settings.json 로드
          settings_path = Path(__file__).parent / "settings.json"
          with open(settings_path, "r", encoding="utf-8") as f:
              settings = json.load(f)

          # 차트 타입별 수집 시작 기준일 생성
          today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
          self.collection_start_times = {
              chart_type: today
              - timedelta(days=settings["chart_collection"][chart_type]["days_ago"])
              for chart_type in ["min", "daily", "weekly"]
          }

          # KIS API 인스턴스 생성
          self.kis = Kis()

          # 데이터 저장 경로 초기화
          self.data_path = Path(__file__).resolve().parent.parent / "data"
          self.data_charts_path = self.data_path / "charts"
          self._init_data_directories()

      def _init_data_directories(self):
          """
          데이터 저장 디렉토리 생성
          (국내(dom) / 해외(ovs) 구분 및 주기(min/daily/weekly) 디렉토리)
          """
          for market in ["dom", "ovs"]:
              market_path = self.data_charts_path / market
              for interval in ["min", "daily", "weekly"]:
                  interval_path = market_path / interval
                  interval_path.mkdir(parents=True, exist_ok=True)
  ```

먼저 `ChartFetcher` 클래스를 선언하고 init 함수를 정의합니다.

settings.json 파일을 로드하고 각 차트 타입별로 데이터 수집 시작 날짜를 계산합니다.

~~예를 들어, 오늘이 2024년 6월 1일이라면 일봉 데이터는 2009년 6월 1일부터 수집하게 되는 거죠.~~

처음 데이터를 조회할 때는 settings 파일에서 설정된 기간만큼 과거 데이터를 충분히 가져옵니다.

만약 다음에 같은 종목의 데이터가 또 필요하면, 현재 저장된 마지막 데이터 이후의 새로운 데이터만 가져오면 됩니다.

이렇게 함으로써

1. API 호출 횟수를 줄일 수 있고,
2. 이미 저장된 데이터의 이후 시점 데이터만 가져옴으로써 중복 데이터를 방지하고,
3. 결과적으로 최종 대시보드에서 데이터 로딩 시간을 단축

할 수 있다는 이점이 있습니다.

다음으로 kis 인스턴스를 생성해서, 필요한 곳에서 사용할 수 있게 했습니다.

kis 인스턴스는 차트 데이터를 가져와 저장하는 get_chart 메서드에서 사용합니다.

입력값을 살펴보면, market, interval 은 국내/해외, 일봉/분봉 등의 조건을 지정합니다.

이 조건에 따라, KIS에서 어떤 메서드를 사용할지 정하게 됩니다.

stock_code, start/end_datetime은 종목과 조회 기 간을 지정합니다.

이 값들은 KIS에서 메서드를 호출할 때 인자로 전달하게 됩니다.

- 코드: get_chart 메서드에서 parameter 옵션 관련

  ```python
  def get_chart(
      self,
      market: Literal["dom", "ovs"],
      stock_code: str,
      start_datetime: datetime = datetime.now() - timedelta(days=365 * 3),
      end_datetime: datetime = datetime.now(),
      interval: Literal["min", "daily", "weekly"] = "daily",
      overwrite: bool = False,
  ) -> pd.DataFrame:
  		...

      # 📌 국내
      if market == "dom":
          if interval == "min":
              chart_chunk = self.kis.get_minute_chart_past(
                  stock_code,
                  date=fetch_end.strftime("%Y%m%d"),
                  time_from=fetch_end.strftime("%H%M%S"),
              )
          elif interval in ["daily", "weekly"]:
              period_code = "D" if interval == "daily" else "W"
              chart_chunk = self.kis.get_period_chart(
                  stock_code,
                  query_start.strftime("%Y%m%d"),
                  fetch_end.strftime("%Y%m%d"),
                  period_code=period_code,
              )
          else:
              raise ValueError(f"Invalid interval: {interval}")

      # 📌 해외
      else:
          if interval == "min":
              chart_chunk = self.kis.get_overseas_minute_chart(
                  ovs_market_code, stock_code, interval=1, include_prev_day=True
              )
          elif interval == "daily":
              chart_chunk = self.kis.get_overseas_period_chart(
                  stock_code,
                  fetch_end.strftime("%Y%m%d"),
                  ovs_market_code,
                  period_code="0",
              )
          else:
              raise ValueError(f"Invalid interval: {interval}")
  ```

지난 시간에 API 소통을 전담하는 kis 모듈을 따로 만들어 두었기 때문에,

차트 데이터 모듈에서는 이렇게 원하는 메서드만 선택해 바로 사용하면 되는 거죠.

간편하게 get_chart 메서드를 호출하기만 하면 되는 거랍니다!

### \_filter_incomplete_candles() 메서드

두 번째 기능은 차트 데이터 미완성 캔들을 제거하는 일인데요,

미완성 캔들이란 무엇일까요?

주식 차트에서 각 봉(캔들)은 하루, 일주일 등 특정 기간 동안의 주가 변동을 나타낸다고 했죠?

그런데 현재 거래 중에 있는 캔들은 아직 완성되지 않은 상태입니다.

예를 들어, 오늘 장 마감시간이 오후 3시 반이라고 했을 때,

오후 1시에 오늘 주가를 조회한다면 완전한 일봉을 가져올 수 없겠죠.

이런 미완성 캔들이 데이터 파일에 저장되면, 나중에 최종적으로 완결된 차트와 우리 파일에 저장된 값이 달라질 수 있어요.

이 문제를 해결하기 위해 미완성 캔들을 필터링하는 메서드를 구현해야 합니다.

- 코드: `_filter_incomplete_candles()`

  ```python
  def _filter_incomplete_candles(
      self, df: pd.DataFrame, interval: str, market: str
  ) -> pd.DataFrame:
      """
      각 interval별 안전하게 완성된 캔들스틱 시점을 반환
      """
      now = datetime.now()
      today_date = now.date()

      if interval == "min":
          safe_cutoff = now.replace(second=0, microsecond=0) - timedelta(minutes=1)
          return df[df.index <= safe_cutoff]

      elif interval == "daily":
          # 오늘 데이터가 있다면 검사
          if today_date in df.index.date:
              if market == "dom":
                  market_close = now.replace(
                      hour=15, minute=30, second=0, microsecond=0
                  )
              elif market == "ovs":
                  market_close = now.replace(
                      hour=6, minute=0, second=0, microsecond=0
                  )
              else:
                  raise ValueError(f"Unknown market type: {market}")

              if now < market_close:
                  # 마감 전이면 오늘 데이터 제거
                  print(f"[INFO] {market.upper()} 시장 마감 전 → 오늘 데이터 제외")
                  return df[df.index.date < today_date]
              else:
                  # 마감 후면 오늘 데이터 포함 저장
                  print(f"[INFO] {market.upper()} 시장 마감 후 → 오늘 데이터 포함")
                  return df

          else:
              return df

      elif interval == "weekly":
          # 주봉은 주말 지나야 확정! (일단 월요일 00시 기준으로)
          safe_week_cutoff = datetime.combine(
              (now - timedelta(days=now.weekday())).date(), datetime.min.time()
          )
          return df[df.index < safe_week_cutoff]

      else:
          return df

  ```

조회 주기별로 경우를 나누어서, 완성된 캔들과 미완성 캔들의 경계를 계산하는 거죠.

이렇게 하면 완성된 캔들만 데이터로 저장하게 되므로, 정확한 데이터만 유지할 수 있습니다.

## 3. Financials.py: DART 기업 고유코드, 기업명 변환

다음으로, 재무제표 데이터를 관리하는 기능도 구현해보겠습니다.

차트와 마찬가지로, 하나의 모듈 안에 클래스를 만들어주겠습니다.

앞서 기본적 분석 강의에서, 애플 같은 해외 기업의 재무제표를 가져오는 연습을 했었죠?

SEC EDGAR API를 사용했었습니다.

### DART API와 고유코드

국내 기업의 재무정보도 비슷한 방법으로 가져올 수 있습니다.

DART, 금융감독원 전자공시시스템을 사용하면 됩니다.

![image.png](attachment:6ed84a0c-e16f-4970-a167-b50078e3a509:image.png)

그런데 DART API를 사용하려면 삼성전자의 005930 처럼 증권사에서 자주 보는 종목 코드가 아닌,

8자리 고유코드(예: 삼성전자의 00126380)가 필요해요.

이 매핑 정보는 XML(엑스 엠 엘) 파일로 제공됩니다.

![image.png](attachment:99f651b5-aaea-4e3a-8e41-e1b45c37563d:image.png)

### 고유코드 파싱 및 변환

이 XML 파일을 파싱하여 고유코드, 종목코드, 기업명 간의 매핑을 구현하면 됩니다.

- 코드: \_fetch_dom_corp_info()

  ```python
      # XML파일 저장 및 조회
      def _fetch_dom_corp_info(self):
          """DART에서 전체 국내 기업 기본 정보 수집"""
          url = f"https://opendart.fss.or.kr/api/corpCode.xml?crtfc_key={DART_API_KEY}"
          response = requests.get(url)

          corp_data = []
          with zipfile.ZipFile(io.BytesIO(response.content)) as zip_file:
              with zip_file.open("CORPCODE.xml") as xml_file:
                  tree = ET.parse(xml_file)
                  root = tree.getroot()

                  for child in root.findall("list"):
                      corp_code = child.find("corp_code").text
                      stock_code = child.find("stock_code").text
                      corp_name = child.find("corp_name").text

                      if stock_code.strip():
                          corp_data.append(
                              {
                                  "corp_code": corp_code,
                                  "stock_code": stock_code,
                                  "corp_name": corp_name,
                              }
                          )

          df = pd.DataFrame(corp_data)
          save_path = self.data_financials_path / "dom" / "info" / "corp_info.csv"
          df.to_csv(save_path, index=False)
          print(f"[INFO] 전체 기업 정보 저장 완료 → {save_path.name}")

          return df
  ```

이렇게 변환한 고유 코드로 DART API 호출을 하면 국내 기업의 재무 정보도 가져올 수 있습니다.

(결과 화면)

그리고, 국내/해외 기업의 종목 코드를 입력 받으면 우리에게 친숙한 기업 이름으로 바꿔주는 메서드도 구현하겠습니다.

- 코드: ticker_to_company_name()
  ```python
  def ticker_to_company_name(
      self, market: Literal["dom", "ovs"], stock_code: str
  ) -> str:
      """종목 코드로 기업명 반환"""
      try:
          if market == "dom":
              _, _, corp_name = self._load_dom_corp_info(stock_code)
          else:
              corp_name = self.stock_mapper.ticker_to_company_name[stock_code]
          return corp_name
      except Exception:
          raise ValueError(f"[ERROR] '{stock_code}'는 유효한 종목 코드가 아닙니다.")
  ```

~~지금 살펴본~~

해외 및 국내 기업 재무 정보를 가져오는 기능, → def get_financials(…)

종목 코드와 고유 코드 매핑 기능, → def \_fetch_dom_corp_info(self):

종목 코드와 기업 이름 매핑 기능들은 모두 하나의 메서드로 만들어서, → def ticker_to_company_name(

필요한 곳에서 사용할 수 있게 준비해 둡니다.

### news.py: NewsFetcher

마지막으로 뉴스 데이터 관리 클래스를 살펴보겠습니다.

이것 역시, 뉴스 분석 강의에서 뉴스 정보를 조회한 것과 같은 방법을 메서드로 만들어 둔 거라고 보시면 됩니다.

이때, 뉴스 데이터를 검색하려면 기업 이름이 필요하죠?

그런데 우리 프로젝트에서는 전체적으로 종목 코드를 기준으로 데이터가 오가게 됩니다.

그래서 NewsFetcher 클래스에서도 종목 코드를 기업 이름으로 변환하는 기능이 필요해요.

방금 재무 데이터 모듈에서 같은 기능을 하는 메서드를 만들었으니, 그걸 재활용하는 것이 효율적입니다.

재무 데이터 관리 클래스를 임포트하고, 종목 코드-기업 이름 매핑 메서드를 뉴스 클래스에서도 편하게 쓸 수 있게 저장합니다.

- 코드: class NewsFetcher 일부

  ```python
  from data_loader.financials import FinancialsFetcher

  ...

  class NewsFetcher:
      """
      뉴스 데이터를 관리하는 클래스
      - 국내(dom) 및 해외(ovs) 시장 뉴스 데이터 지원
      - 데이터 저장, 병합, 필터링, API 호출 관리
      """

      def __init__(self):
          # settings.json 파일 로드
          settings_path = Path(__file__).parent / "settings.json"
          with open(settings_path, "r", encoding="utf-8") as f:
              settings = json.load(f)

          # 뉴스 업데이트 기준 시간 설정(ex: 1시간)
          self.update_threshold = timedelta(
              hours=settings["news_collection"]["hours_threshold"]
          )

          # 데이터 저장 경로 설정
          self.data_path = Path(__file__).resolve().parent.parent / "data"
          self.data_news_path = self.data_path / "news"
          self._init_data_directories()

          # 종목코드-기업명 매핑을 위한 객체들 초기화
          self.ticker_to_name = FinancialsFetcher().ticker_to_company_name
  ```

그리고 업데이트 시점도 settings 파일을 가져와 차트 모듈에서 했던 것과 비슷하게 관리합니다.

## 마무리

자, 이렇게 데이터 관리 패키지 구현이 끝났습니다!

다음 시간에는 이렇게 체계적으로 수집한 데이터를 분석해서,

보고서를 생성하고 저장하는 단계까지 구현해보겠습니다.

그럼 다음 시간에 만나요! 감사합니다.

---

### 1️⃣ 데이터 관리 패키지의 필요성

- 최종 대시보드에서는 다음과 같이 주식 관련 데이터를 조회하고 처리합니다.
  - 다양한 종목의 차트 데이터를 조회할 수 있어야 합니다.
  - 선택한 기간의 데이터를 보여줄 수 있어야 합니다.
  - 실시간으로 최신 정보를 반영해야 합니다.
- API 호출을 최소화하고 데이터를 효율적으로 관리할 수 있는 시스템이 필요합니다.
  - 불필요한 API 호출은 서버에 부담을 줍니다.
  - 데이터 중복 저장은 저장 공간을 낭비하고, 혼동을 유발합니다.
- 데이터 관리 패키지에서 체계적으로 데이터를 관리하여, 최종 대시보드에서 데이터 로딩 시간을 단축할 수 있습니다.

### 2️⃣ 데이터 관리 패키지(data_loader) 구조

- 데이터의 유형에 따라 모듈을 분리합니다.
  - `chart.py`: 차트 데이터 관리 (`ChartFetcher` 클래스)
  - `financials.py`: 재무 데이터 관리 (`FinancialsFetcher` 클래스)
  - `news.py`: 뉴스 데이터 관리 (`NewsFetcher` 클래스)
- 모듈을 하나의 패키지로 통합하여 사용합니다.
  - `__init__.py` 파일을 추가하여 패키지로 인식되게 합니다.
  - 외부에서 필요한 기능만 임포트하여 사용할 수 있습니다.

```python
# data_loader/__init__.py 예시
from .chart import ChartFetcher
from .financials import FinancialsFetcher
from .news import NewsFetcher

__all__ = ["ChartFetcher", "FinancialsFetcher", "NewsFetcher"]
```

<aside>
➕

**파이썬 패키지에서 **init**.py 파일의 역할**

- 패키지 선언: 이 파일이 있는 디렉토리는 파이썬이 패키지로 인식합니다.
- 초기화 코드 실행: **init** 파일의 코드는 패키지가 처음 임포트될 때 실행됩니다.
- 외부로 노출할 대상 지정: **all** 리스트를 통해 이 패키지를 외부에서 사용할 때 어떤 클래스가 노출될 지 제어할 수 있습니다.
</aside>

### 3️⃣ 데이터 조회 시점 관리

- 설정 파일(settings.json)을 통해 데이터 수집 주기와 기간을 관리합니다.
  - 데이터 초기 로딩 시 충분한 과거 데이터를 확보하고, 이후에는 최신 데이터만 조금씩 추가하는 전략이 효율적입니다.
  - 이 프로젝트에서는 7일 분의 분봉 데이터, 5년 분의 일봉 데이터, 10년 분의 주봉 데이터를 수집하고 1시간마다 뉴스 데이터를 업데이트하도록 설정했습니다.

```json
{
  "chart_collection": {
    "min": {
      "days_ago": 7,
      "description": "분봉 데이터는 7일 전부터 수집"
    },
    "daily": {
      "days_ago": 1825,
      "description": "일봉 데이터는 5년 전부터 수집"
    },
    "weekly": {
      "days_ago": 3650,
      "description": "주봉 데이터는 10년 전부터 수집"
    }
  },
  "news_collection": {
    "hours_threshold": 1
  }
}
```

- 설정 파일을 바탕으로, `ChartFetcher` 클래스를 초기화할 때 데이터 수집 시작 시점을 계산합니다.

```python
class ChartFetcher:
    def __init__(self):
        """
        설정 초기화 및 데이터 디렉토리 구성
        """
        # settings.json 로드
        settings_path = Path(__file__).parent / "settings.json"
        with open(settings_path, "r", encoding="utf-8") as f:
            settings = json.load(f)

        # 차트 타입별 수집 시작 기준일 생성
        today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        self.collection_start_times = {
            chart_type: today
            - timedelta(days=settings["chart_collection"][chart_type]["days_ago"])
            for chart_type in ["min", "daily", "weekly"]
        }

        # KIS API 인스턴스 생성
        self.kis = Kis()

        # 데이터 저장 경로 초기화
        self.data_path = Path(__file__).resolve().parent.parent / "data"
        self.data_charts_path = self.data_path / "charts"
        self._init_data_directories()
```

### 4️⃣ 차트 데이터 관리 (ChartFetcher)

- `get_chart()`: 시장 및 차트 유형(market, interval), 종목코드(stock_code), 조회 기간(start_datetime, end_datetime)을 기준으로 차트 데이터를 가져와 저장합니다.

```python
def get_chart(
    self,
    market: Literal["dom", "ovs"],
    stock_code: str,
    start_datetime: datetime = datetime.now() - timedelta(days=365 * 3),
    end_datetime: datetime = datetime.now(),
    interval: Literal["min", "daily", "weekly"] = "daily",
    overwrite: bool = False,
) -> pd.DataFrame:
		...

    # 📌 국내
    if market == "dom":
        if interval == "min":
            chart_chunk = self.kis.get_minute_chart_past(
                stock_code,
                date=fetch_end.strftime("%Y%m%d"),
                time_from=fetch_end.strftime("%H%M%S"),
            )
        elif interval in ["daily", "weekly"]:
            period_code = "D" if interval == "daily" else "W"
            chart_chunk = self.kis.get_period_chart(
                stock_code,
                query_start.strftime("%Y%m%d"),
                fetch_end.strftime("%Y%m%d"),
                period_code=period_code,
            )
        else:
            raise ValueError(f"Invalid interval: {interval}")

    # 📌 해외
    else:
        if interval == "min":
            chart_chunk = self.kis.get_overseas_minute_chart(
                ovs_market_code, stock_code, interval=1, include_prev_day=True
            )
        elif interval == "daily":
            chart_chunk = self.kis.get_overseas_period_chart(
                stock_code,
                fetch_end.strftime("%Y%m%d"),
                ovs_market_code,
                period_code="0",
            )
        else:
            raise ValueError(f"Invalid interval: {interval}")
    ...
```

- `_filter_incomplete_candles()`: 차트 데이터 중 미완성 캔들이 있다면 필터링합니다.
  - 예를 들어 일봉 데이터의 경우, 장 마감 시각 market_close를 기준으로 오늘 데이터를 포함할지 결정합니다.

```python
def _filter_incomplete_candles(
    self, df: pd.DataFrame, interval: str, market: str
) -> pd.DataFrame:
    """
    각 interval별 안전하게 완성된 캔들스틱 시점을 반환
    """
    now = datetime.now()
    today_date = now.date()

    if internal == "min": #
        safe_cutoff = now.replace(second=0, microsecond=0) - timedelta(minutes=1)
        return df[df.index <= safe_cutoff]

    elif interval == "daily":
        # 오늘 데이터가 있다면 검사
        if today_date in df.index.date:
            if market == "dom":
                market_close = now.replace(
                    hour=15, minute=30, second=0, microsecond=0
                )
            elif market == "ovs":
                market_close = now.replace(
                    hour=6, minute=0, second=0, microsecond=0
                )
            else:
                raise ValueError(f"Unknown market type: {market}")

            if now < market_close:
                # 마감 전이면 오늘 데이터 제거
                return df[df.index.date < today_date]
            else:
                # 마감 후면 오늘 데이터 포함 저장
                return df

        else:
            return df

    elif interval == "weekly":
        # 주봉은 주말 지나야 확정: 일단 월요일 00시 기준으로
        safe_week_cutoff = datetime.combine(
            (now - timedelta(days=now.weekday())).date(), datetime.min.time()
        )
        return df[df.index < safe_week_cutoff]

    else:
        return df
```

<aside>
➕

**미완성 캔들이란?**

- 주식 차트에서 캔들은 특정 기간(분, 일, 주 등)의 가격 변동을 나타냅니다.
- 미완성 캔들은 해당 기간이 종료되지 않아 확정되지 않은 캔들을 의미합니다.
  - 예를 들어, 오늘의 일봉 캔들은 장 마감 전에는 미완성 상태입니다.
- 미완성 캔들을 저장하면 나중에 완성된 캔들과 불일치하거나 시점이 중복될 수 있으므로, 분석의 정확성을 위해 제거합니다.
</aside>

<aside>
➕

**ChartFetcher 클래스의 세부 메서드**

- **init**(): 클래스 객체 초기화
- \_init_data_directories(): 데이터 저장 디렉토리 초기화
- 차트 데이터 조회
  - get_chart(): 차트 데이터 조회 및 반환
  - \_get_interval_timedelta(): 차트 간격 기준 시간 반환
- 차트 데이터 저장 및 로드
  - \_save_chart_data(): 차트 데이터 파일 저장
  - \_read_chart_data(): 기존 차트 데이터 읽어오기
- 차트 데이터 검증
  - \_filter_incomplete_candles(): 미완성 캔들 데이터 필터링
- 차트 데이터 수집 - \_fetch_domestic_chart(): 국내 주식 차트 데이터 수집 - \_fetch_overseas_chart(): 해외 주식 차트 데이터 수집
</aside>

### 5️⃣ 재무 데이터 관리 (FinancialsFetcher)

- 국내 기업의 재무제표는 금융감독원 전자공시시스템(DART)에서 가져올 수 있습니다.
  - DART API를 사용하려면 종목 코드와 별개로 8자리 고유 코드가 필요합니다.
  - 고유코드, 종목코드, 기업명에 관한 정보는 DART에서 JSON 또는 XML 형식으로 내려받을 수 있습니다.

```xml
<list>
    <corp_code>00126380</corp_code>
    <corp_name>삼성전자</corp_name>
    <corp_eng_name>SAMSUNG ELECTRONICS CO,.LTD</corp_eng_name>
    <stock_code>005930</stock_code>
    <modify_date>20240522</modify_date>
</list>
```

- `_fetch_dom_corp_info()`: 기업 정보를 파싱하여 고유 코드, 종목 코드, 기업명 정보만 저장합니다.

```python
def _fetch_dom_corp_info(self, ticker: str):
    """DART에서 국내 기업 기본 정보 조회 후 저장"""
    url = f"https://opendart.fss.or.kr/api/company.json?crtfc_key={DART_API_KEY}&corp_code={ticker}"

    response = requests.get(url)
    data = response.json()

    if "status" in data and data["status"] != "013":
        corp_code = data.get("corp_code", "")
        corp_name = data.get("corp_name", "")
        stock_code = data.get("stock_code", "")

        df = pd.DataFrame([{
		        "corp_code": corp_code,
		        "stock_code": stock_code,
		        "corp_name": corp_name,
            }])

        save_path = (
            self.data_financials_path / "dom" / "info" / f"{ticker}_info.csv"
        )
        df.to_csv(save_path, index=False)
```

- `ticker_to_company_name()`: 종목코드를 기업 이름으로 변환합니다.

```python
def ticker_to_company_name(
    self, market: Literal["dom", "ovs"], stock_code: str
) -> str:
    """종목 코드로 기업명 반환"""
    try:
        if market == "dom":
            _, _, corp_name = self._load_dom_corp_info(stock_code)
        else:
            corp_name = self.stock_mapper.ticker_to_company_name[stock_code]
        return corp_name
    except Exception:
        raise ValueError(f"[ERROR] '{stock_code}'는 유효한 종목 코드가 아닙니다.")
```

<aside>
➕

**FinancialsFetcher 클래스의 세부 메서드**

- **init**(): 클래스 객체 초기화
- \_init_data_directories(): 데이터 저장 디렉토리 초기화
- 재무 데이터 조회
  - get_financials(): 국내외 재무 데이터 조회 및 반환
  - \_fetch_overseas_financials(): SEC EDGAR API를 통해 해외 기업 재무 데이터 수집
  - \_fetch_overseas_financials(): DART API를 통해 국내 기업 재무 데이터 수집
  - \_fetch_dom_corp_info(): DART API를 통해 국내 기업 기본 정보 수집 및 저장
  - \_load_dom_corp_info(): 국내 기업의 기본 정보 읽어오기
- 재무 데이터 저장 및 로드
  - \_save_financials_data(): 조회 및 병합된 재무 데이터를 CSV 파일로 저장
  - \_read_financials_data(): 재무 데이터를 CSV 파일에서 읽어오기
- 기업 정보 조회
  - ticker_to_company_name(): 기업의 기본정보를 기반으로 종목코드를 기업명으로 변환
- 재무 데이터 업데이트 이력 관리 - \_get_latest_year(): 재무 데이터 중 가장 최근 연도 반환
</aside>

### 6️⃣ 뉴스 데이터 관리 (NewsFetcher)

- 뉴스 데이터 수집 클래스를 초기화합니다.
  - 설정 파일을 참고해 뉴스 데이터 갱신 시점을 관리합니다.
  - `FinancialsFetcher` 클래스에서 종목 코드-기업명을 매핑하는 메서드(ticker_to_company_name)를 가져와 활용합니다.

```python
from data_loader.financials import FinancialsFetcher

...

class NewsFetcher:
    """
    뉴스 데이터를 관리하는 클래스
    - 국내(dom) 및 해외(ovs) 시장 뉴스 데이터 지원
    - 데이터 저장, 병합, 필터링, API 호출 관리
    """

    def __init__(self):
        # settings.json 파일 로드
        settings_path = Path(__file__).parent / "settings.json"
        with open(settings_path, "r", encoding="utf-8") as f:
            settings = json.load(f)

        # 뉴스 업데이트 기준 시간 설정(ex: 1시간)
        self.update_threshold = timedelta(
            hours=settings["news_collection"]["hours_threshold"]
        )

        # 데이터 저장 경로 설정
        self.data_path = Path(__file__).resolve().parent.parent / "data"
        self.data_news_path = self.data_path / "news"
        self._init_data_directories()

        # 종목코드-기업명 매핑을 위한 객체들 초기화
        self.ticker_to_name = FinancialsFetcher().ticker_to_company_name
```

<aside>
➕

**NewsFetcher 클래스의 세부 메서드**

- **init**(): 클래스 객체 초기화
- \_init_data_directories(): 데이터 저장 디렉토리 초기화
- 뉴스 데이터 조회
  - get_news(): 뉴스 데이터 조회 및 저장
  - \_fetch_news(): Google News RSS 피드에서 최신 뉴스 100건 조회
- 뉴스 데이터 저장 및 로드
  - \_save_news_data(): 뉴스 데이터를 CSV 파일로 저장
  - \_read_news_data(): 저장된 뉴스 데이터를 CSV 파일에서 읽어오기
- 기업 정보 조회 데이터 검증 - \_filter_incomplete_news(): 미완성 뉴스 필터링
</aside>
