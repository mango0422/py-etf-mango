안녕하세요, 여러분! 지난 시간에는 데이터 관리 패키지를 구현했습니다.

오늘은 그렇게 수집한 데이터를 분석하고 보고서를 생성하는 분석 패키지를 구성해보겠습니다.

## 분석 패키지의 역할

데이터 관리 시스템에서 요리를 위한 재료를 깔끔하게 손질하는 역할을 했다면,

분석 패키지의 역할은 이 재료를 가지고 실제 요리를 만들어내는 역할이라고 할 수 있습니다.

기술적 분석, 기본적 분석, 뉴스 분석과 같은 다양한 보고서들이 그 요리에 해당하죠.

각 분석 모듈에서는 다음과 같은 일들을 처리합니다:

- 각 데이터 유형에 맞는 데이터를 가져옵니다.
- 가져온 데이터를 대시보드에 표시할 수 있는 형식으로 가공합니다.

따라서 기본적으로 이런 메서드들이 필요하겠죠:

![영상: 데이터 조회, 보고서 생성 메서드만 강조 (볼드체)](attachment:96b8e97b-ed6c-4a35-a87e-4a098dfed988:image.png)

영상: 데이터 조회, 보고서 생성 메서드만 강조 (볼드체)

여기에 더해, 분석에 사용하는 데이터와, 보고서 생성 시점을 관리하는 기능을 추가할 거예요.

그럼 각 모듈을 하나씩 살펴보겠습니다.

## 기술적 분석 모듈 (technical.py)

기술적 분석 모듈의 구체적인 코드를 살펴보기 전에,

대시보드와 이 모듈이 어떻게 연결되어야 하는지 먼저 살펴봅시다.

대시보드에는 기술적 분석 보고서와 함께, 주가 데이터를 상호작용 가능한 차트 형식으로도 보여주기로 했었죠.

여기서 추가 기술 지표가 포함된 풍부한 차트를 표시해주고, 

기술적 분석 보고서까지 생성하는 역할을 담당하도록 할게요.

### 이동평균선이 추가된 차트 데이터 생성

먼저 이 ‘풍부한 차트’부터 짚고 넘어갈게요.

증권사 서비스를 보면 주가 차트는 단순히 가격만 표시하는 게 아니라, 주가를 바탕으로 계산한 여러 기술 지표들을 같이 보여줍니다.

이런 내용을 반영해서 앞에서 수행한 기술적 분석에서는 최근 6개월 차트에 이동평균선을 포함해 분석했었죠.

기술 분석 모듈에서는 이를 get_rich_chart()라는 메서드로 구현했습니다.

빈도 파라미터로 차트 데이터의 주기를 선택할 수 있게 했는데요,

일단은 일봉 기준으로 살펴보겠습니다.

- 코드: get_rich_chart() 일부
    
    ```python
    async def get_rich_chart(self, market, stock_code, date_range: list, freq="daily"):
        """차트 데이터 + 이동평균선"""
        ...
        
        chart = self.chart_fetcher.get_chart(
            market,
            stock_code,
            start_datetime=date_range[0] - timedelta(days=180), # 이동평균 계산 위해 여유있게 가져옴
            end_datetime=date_range[1],
            interval=freq, # 데이터 주기
        )
    
        # 이동평균선 계산
        if freq == "daily":
            chart["MA5"] = chart.ta.sma(length=5)
            chart["MA20"] = chart.ta.sma(length=20)
            chart["MA60"] = chart.ta.sma(length=60)
            chart["MA120"] = chart.ta.sma(length=120)
        ...
    
        # 필터링
        start_ts, end_ts = pd.Timestamp(date_range[0]), pd.Timestamp(date_range[1])
        chart_filtered = chart[(chart.index >= start_ts) & (chart.index <= end_ts)]
    
        return chart_filtered
    
    ```
    

get_rich_chart()는 시장 구분, 종목 코드, 조회 기간, 조회 주기를 입력으로 받아

원본 차트와 이동평균선 데이터를 하나의 데이터프레임으로 반환하는 메서드인데요,

1. 이동평균 계산을 위해 요청한 기간보다 더 넓은 범위의 데이터를 가져옵니다.
2. pandas_ta 라이브러리를 사용해 이동평균선을 계산합니다.
3. 최종적으로 사용자가 요청한 기간에 맞게 데이터를 필터링합니다.

대시보드에서는 이 데이터프레임을 보기 좋은 차트로 표시해주면 되겠죠.

### 기술적 지표 계산

다음으로 기술적 분석 보고서를 생성하기 전에,

분석에 사용할 기술적 지표를 계산하는 메서드를 먼저 구현해보겠습니다.

이번에는 이동평균 지표에 더해, RSI와 볼린저 밴드라는 지표까지 계산해 볼게요.

차트 데이터를 더 다양한 관점에서 분석하고, 각 지표의 한계를 보완하기 위해

AI 분석에 더 다양한 기술 지표를 반영해보고자 합니다.

- 코드: get_technical_indicators()
    
    ```python
    def get_technical_indicators(self, df, freq="daily") -> pd.DataFrame:
        """기술적 지표 계산"""
        if "last" in df.columns: # ta 메서드를 위해 컬럼 이름 통일
            df.rename(columns={"last": "close"}, inplace=True)
    
        # 주기에 따라 지표 다르게
        if freq == "min":
            # 분봉 기준 지표 (단기 중심)
            df_sma = df.ta.sma(length=10)
            df_ema = df.ta.ema(length=10)
            df_rsi = df.ta.rsi(length=7)
        elif freq == "weekly":
            # 주봉 기준 지표 (장기 중심)
            df_sma = df.ta.sma(length=60)
            df_ema = df.ta.ema(length=60)
            df_rsi = df.ta.rsi(length=21)
        else:
            # 일봉 기준 기본 지표
            df_sma = df.ta.sma(length=20)
            df_ema = df.ta.ema(length=20)
            df_rsi = df.ta.rsi(length=14)
    
        df_boll = df.ta.bbands(length=20, std=2)
        df_indicators = pd.concat([df, df_sma, df_ema, df_rsi, df_boll], axis=1)
    
        return df_indicators
    ```
    

이 함수는 `데이터 주기`(분봉, 일봉, 주봉)에 따라 적절한 기간의 지표를 계산합니다.

예를 들어 분봉 데이터는 단기 지표 위주로, 주봉 데이터는 장기 지표 위주로 계산하죠.

이렇게 계산한 기술적 지표는 get_report 메서드에서 AI에게 보고서 생성을 요청할 때, 프롬프트에 포함해 전달합니다.

- get_report에서 프롬프트에 기술적 지표 추가
    
    ```python
    async def get_report(
            self,
            market: str,
            stock_code: str,
            overwrite=False,
            freq="daily",
            extra_prompt="",
        ) -> str:
        
        ...
        
        # 기술적 지표 가져오기
        df_indicators = self.get_technical_indicators(chart_data)
        
        stocks_json = chart_data.to_json(orient="records", indent=4, force_ascii=False)
    
            indicators_json = df_indicators.to_json(
                orient="records", indent=4, force_ascii=False
            )
            # chart 데이터 → JSON 변환
            currency = "₩" if market == "dom" else "$"
    
            prompt_tech_user = f"""
            최근 일봉 차트 데이터({currency}): {stocks_json}
            기술적 지표: {indicators_json}
            """
    ```
    

최종적으로 대시보드에서는 get_report 메서드만 호출하면 보고서 데이터를 가져올 수 있게 구현합니다.

## 기본적 분석 모듈 ([fundamental.py](http://fundamental.py/))

두 번째로 기본적 분석 모듈은 재무제표 데이터를 활용해 기업의 재무 상태를 분석하고,

이를 바탕으로 AI가 기본적 분석 보고서를 생성하는 역할을 합니다.

우리가 만들 대시보드의 기본적 분석 영역을 생각해볼까요?

여기에는 재무 지표를 표와 그래프로 시각화하고, 여기에 AI가 생성한 기본적 분석 보고서를 함께 표시하기로 했었죠.

이걸 위해서는 몇 가지 핵심 메서드가 필요합니다.

먼저 보고서를 생성하기 위해서는 원본 재무 데이터를 가져오는 `_get_financials()` 메서드가 필요합니다.

또, 재무 지표를 가져오는 `get_indicators()` 메서드가 필요합니다. 이 메서드는 주요 재무 지표들을 kis 모듈을 통해 가져와 반환해 줄 거예요.

그리고 마지막으로, 이 모든 데이터를 종합해서 AI 분석 보고서를 생성하는 `get_report()` 메서드도 구현합니다.

9강에서 원본 재무제표와 함께, 재무 지표 데이터까지 활용해 종합적이고 자세한 분석 보고서를 생성한 것 기억나시죠?

한 쪽에는 재무 지표들을 표시하기로 했으니, 원하는 형태로 시각화하기 위한 메서드도 필요합니다.

- `get_indicators_table_data()`: 표 형태로 보여줄 데이터를 정리해 반환하는 메서드,
- `get_indicators_graph_data()`: 그래프로 그릴 데이터를 정리해 반환하는 메서드입니다.

결국 우리 대시보드는 이 모든 메서드들이 반환한 데이터를 한 화면에 모아서 보여주게 됩니다.

### ~~캐시를 활용한 효율적인 데이터 관리~~

~~기본적 분석 모듈에서 한 가지 주의할 점은, 재무제표 데이터의 용량이 크고, 이에 따라 응답 대기 시간도 길어진다는 것입니다.~~

~~따라서 한번 가져온 데이터는 메모리에 캐시(임시 저장)해두고 재사용하는 것이 효율적입니다.~~

- ~~코드: class FundamentalAnalysis 일부~~
    
    ```python
    class FundamentalAnalysis:
    		def __init__(self):
    				...
    		    # 재무제표 캐시
    		    # 키: (market, stock_code) 튜플
    		    # 값: (재무제표 데이터: pd.DataFrame, 기업명: str) 튜플
    		    self.financials_cache = {}
    		
    		    # 중간 지표 캐시
    		    # 키: (market, stock_code) 튜플
    		    # 값: 중간 지표 데이터
    		    self.indicators_cache = {}
    		    
    		...
    		
    		def _get_financials(
    		    self, market: Literal["dom", "ovs"], stock_code: str
    		) -> pd.DataFrame:
    		    """재무제표 데이터 로드"""
    		    # 캐시에 있으면 바로 반환
    		    if (market, stock_code) in self.financials_cache:
    		        return self.financials_cache[(market, stock_code)]
    		
    		    # 캐시에 없으면 새로 로드
    		    financials = self.financials_fetcher.get_financials(market, stock_code)
    		    corp_name = self.financials_fetcher.ticker_to_company_name(market, stock_code)
    		    self.financials_cache[(market, stock_code)] = financials, corp_name
    		    return financials, corp_name
    		    
    			  ...
    
    ```
    

~~여기서 캐시란 자주 접근하는 데이터의 복사본을 임시로 저장해두는 공간을 말합니다.~~

~~평소에는 요리 도구를 찬장에 넣어 두지만,~~

~~요리할 때 자주 필요한 도구는 손이 잘 닿는 곳에 두고 사용하죠.~~

~~비슷하게, 같은 종목을 여러 번 분석한다면 API를 매번 다시 호출하는 대신,~~

~~지난 호출 결과를 잠시 변수로 저장해두는 게 좋겠죠.~~

~~다만, 이렇게 저장한 캐시는 프로그램이 실행되는 동안만 유지되며, 종료되면 사라진다는 점에 주의해 주세요.~~

~~따라서 완전한 영구 저장이 필요한 데이터는 파일로 저장해야 합니다.~~

## 구조화된 출력 제어

다음으로, 더 안정적인 시스템을 위한 구조화된 출력을 좀 더 세세히 살펴보겠습니다.

지난번에 보고서를 생성하면서, AI에게 JSON 출력 형식을 지정해달라고 했었죠.

뉴스 보고서에서 사용한 JSON 스키마를 예시로 보겠습니다.

- 코드: news_format
    
    ```json
    news_format = {
        "type": "json_schema",
        "json_schema": {
            "name": "news_analysis",
            "strict": True,
            "schema": {
                "type": "object",
                "properties": {
                    "articles": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "index": {"type": "integer"},
                                "title": {"type": "string"},
                                "reason": {"type": "string"},
                                "sentiment": {
                                    "type": "string",
                                    "enum": ["긍정 🌞", "부정 ⛈️", "중립 ⛅"],
                                },
                            },
                            "required": ["index", "title", "reason", "sentiment"],
                            "additionalProperties": False,
                        },
                    },
                    "overall_sentiment": {
                        "type": "integer"
                    },
                    "sentiment_emoji": {
                        "type": "string",
                        "enum": ["🟢", "🔴", "🟡"],
                    },
                },
                "required": ["articles", "overall_sentiment", "sentiment_emoji"],
                "additionalProperties": False,
            },
        },
    }
    ```
    

이 중에서 네 가지 옵션이 하는 역할만 살펴볼게요.

1. `"strict": True:` strict 옵션은 AI가 반드시 정의된 스키마를 따르도록 강제합니다.
2. `"required": ["index", "title", "reason", "sentiment"]` required 옵션에서는 스키마의 필수 필드들을 지정하여 항목이 누락되지 않게 합니다.
3. `object`필드에서 `"additionalProperties"`는 `False`로 지정하여 미리 지정하지 않은 필드를 불필요하게 출력하지 않게 합니다.
4. `"enum": ["긍정 🌞", "부정 ⛈️", "중립 ⛅"]`, `"enum": ["🟢", "🔴", "🟡"]`: enum 옵션은 특정 필드의 값이 미리 정해진 목록 중 하나만 될 수 있도록 제한합니다. 여기서는 감성을 날씨 이모지로 표현하게 해 볼게요.

~~스키마의 다른 부분은 AI로 생성하거나, 자유롭게 설정할 수 있지만,~~

일관된 형식을 유지하는 데 어떤 옵션이 필요한지는 알아두는 게 좋습니다.

최종 대시보드에서 보기 좋게 시각화 하기 위해, 예측 가능한 방식으로 결과를 얻어낼 수 있어야 하니까요.

## 보고서 매니저 모듈

마지막으로 보고서 매니저 모듈은 여러 보고서의 생성 시점과 업데이트 주기를 관리합니다.

대시보드에서 종목을 조회할 때마다 매번 새 보고서를 생성할 수도 있겠지만,

AI 모델 호출은 시간이 오래 걸리는 편이라 매번 대기 시간이 길어지고,

이미 생성된 보고서가 있을 때 굳이 새로 생성하는 것은 낭비이기도 합니다.

그러니 우리는 적절한 기준을 정해, 그 기준보다 오래된 보고서만 업데이트하기로 해봅시다.

보고서 업데이트 주기는 JSON 파일로 관리합니다:

- analysis_settings.json
    
    ```json
    {
        "fundamental": {
            "update_interval": {
                "days": 7,
                "description": "기본/재무 분석 보고서는 7일마다 갱신"
            }
        },
        "technical": {
            "min": {
                "update_interval": {
                    "hours": 1,
                    "description": "분봉 데이터는 1시간마다 갱신"
                }
            },
            "daily": {
                "update_interval": {
                    "days": 1,
                    "description": "일봉 데이터는 1일마다 갱신"
                }
            },
            "weekly": {
                "update_interval": {
                    "days": 7,
                    "description": "주봉 데이터는 7일마다 갱신"
                }
            }
        },
        "news": {
            "update_interval": {
                "hours": 6,
                "description": "뉴스 분석 보고서는 6시간마다 갱신"
            }
        }
    }
    
    ```
    

이 설정 파일을 통해 각 보고서 종류별로 업데이트 주기를 쉽게 관리할 수 있습니다:

- 기본적 분석 보고서는 주로 재무제표라는 장기 데이터에 의존하기 때문에 7일마다 갱신하고,
- 일봉 데이터를 사용한 기술적 분석 보고서는 1일마다,
- 뉴스 분석 보고서는 6시간마다 갱신해 좀 더 최신 정보가 반영되도록 합니다.

이 관리 기능은 report_manager 모듈에 별도로 구현했는데요,

각 보고서 생성 모듈을 초기화 할 때 보고서 관리자 객체를 선언하고,

보고서 경로와, 유형에 맞게 보고서 파일과 업데이트 시점을 관리합니다.

- 코드: ReportManager 활용 예시
    
    ```jsx
    class TechnicalAnalysis:
        def __init__(self):
        ...
    				self.report_manager = ReportManager(
    				    report_root=project_root / "report",
    				    report_type="fundamental",  # 폴더 구분용
    				    settings=settings["fundamental"],  # update_interval이 들어있는 딕셔너리
    				)
    		...
    ```
    
    ```python
    class TechnicalAnalysis:
    		...				
    		async def get_report(self):
    		    self,
            market: str,
            stock_code: str,
            overwrite=False,
            freq="daily",
            extra_prompt="",
        ) -> str:
            # 1. 최신 리포트 파일 확인
            latest_report = self.report_manager.get_latest_report(market, stock_code)
    
            if latest_report:
                latest_time, latest_file = latest_report
                if not overwrite and not self.report_manager.is_update_required(
                    latest_time
                ):
                    return latest_file.read_text(encoding="utf-8")
                else:
                    print(f"[업데이트 필요] {stock_code} 기술적 분석 리포트 갱신 중...")
    
            else:
                print(f"[신규 생성] {stock_code} 기술적 분석 리포트 생성 중...")
            
            ...
    ```
    

보고서 생성 메서드 get_report()에서 이 관리자 객체를 사용하게 되는데요, 

1. 먼저 최신 보고서 파일이 있는지 확인합니다.
2. 있다면 생성 시간을 확인하고, 업데이트가 필요한지 판단합니다.
3. 업데이트가 필요하지 않으면 기존 보고서를 반환하고, 필요하면 새로 생성합니다.

## 마무리

자, 이렇게 분석 기능을 담당하는 패키지의 구현이 끝났습니다!

이제 대시보드에 표시해야 할 정보를 가공하는 과정은 모두 준비되었습니다.

다음 시간에는 지금까지 만든 모든 모듈과 패키지를 통합하여 최종 대시보드를 구축하는 방법에 대해 알아보겠습니다.

그럼 다음 시간에 만나요~

---

### 1️⃣ 분석 패키지의 역할

- 분석 패키지(analysis)는 수집한 데이터를 AI 모델에 입력하여 분석 보고서를 생성합니다.
- 분석할 데이터 유형에 따라 모듈을 분리합니다.
    - technical.py: 차트 데이터를 받아 기술 분석 보고서를 생성합니다. (TechnicalAnalysis 클래스)
    - fundamental.py: 재무 데이터를 받아 기본 분석 보고서를 생성합니다. (FundamentalAnalysis 클래스)
    - news.py: 뉴스 데이터를 받아 뉴스 분석 보고서를 생성합니다. (NewsAnalysis 클래스)
    - report_manager.py: 전체 보고서들을 조회하고, 저장하는 관리 기능을 수행합니다. (ReportManager 클래스)
- 데이터 관리 패키지가 데이터라는 '재료를 손질'해줬다면, 분석 패키지는 실제로 ‘요리’하는 단계를 담당합니다.

### 2️⃣ 차트 데이터로 기술적 분석 수행하기 (TechnicalAnalysis)

- `get_rich_chart()`: 주가 차트에 기술적 지표를 추가한 '풍부한 차트' 데이터를 생성합니다.

```python
async def get_rich_chart(self, market, stock_code, date_range: list, freq="daily"):
    """차트 데이터 + 이동평균선"""
    ...
    
    chart = self.chart_fetcher.get_chart(
        market,
        stock_code,
        start_datetime=date_range[0] - timedelta(days=180), # 이동평균 계산 위해 여유있게 가져옴
        end_datetime=date_range[1],
        interval=freq, # 데이터 주기
    )

    # 이동평균선 계산
    if freq == "daily":
        chart["MA5"] = chart.ta.sma(length=5)
        chart["MA20"] = chart.ta.sma(length=20)
        chart["MA60"] = chart.ta.sma(length=60)
        chart["MA120"] = chart.ta.sma(length=120)
    ...

    # 필터링
    start_ts, end_ts = pd.Timestamp(date_range[0]), pd.Timestamp(date_range[1])
    chart_filtered = chart[(chart.index >= start_ts) & (chart.index <= end_ts)]

    return chart_filtered
```

- `get_technical_indicators()`: 분석을 위한 다양한 기술적 지표를 계산합니다.
    - pandas-ta 라이브러리를 활용하면 차트 데이터가 담긴 데이터프레임에서 바로 기술 지표를 계산할 수 있습니다.

```python
import pandas_ta as ta 

def get_technical_indicators(self, df, freq="daily") -> pd.DataFrame:
    """기술적 지표 계산"""
    if "last" in df.columns: # ta 메서드를 위해 컬럼 이름 통일
        df.rename(columns={"last": "close"}, inplace=True)

    # 차트 주기에 따라 지표 계산 기간 다르게 설정
    if freq == "min":
        # 분봉 기준 지표 (단기 중심)
        df_sma = df.ta.sma(length=10)
        df_ema = df.ta.ema(length=10)
        df_rsi = df.ta.rsi(length=7)
    elif freq == "weekly":
        # 주봉 기준 지표 (장기 중심)
        df_sma = df.ta.sma(length=60)
        df_ema = df.ta.ema(length=60)
        df_rsi = df.ta.rsi(length=21)
    else:
        # 일봉 기준 기본 지표
        df_sma = df.ta.sma(length=20)
        df_ema = df.ta.ema(length=20)
        df_rsi = df.ta.rsi(length=14)

    # 볼린저 밴드 계산
    df_boll = df.ta.bbands(length=20, std=2)

    # 모든 지표 병합
    df_indicators = pd.concat([df, df_sma, df_ema, df_rsi, df_boll], axis=1)

    return df_indicators
```

<aside>
➕

**주요 기술적 지표와 그 개념**

- SMA(단순이동평균선): 일정 기간의 가격 평균을 계산한 선
- EMA(지수이동평균선): 최근 가격에 더 높은 가중치를 두는 이동평균선
- RSI(상대강도지수): 주가의 상승 압력과 하락 압력 간의 상대적인 강도를 나타내는 지표 (0~100 사이 값)
- 볼린저 밴드: 주가의 중심선(이동평균선)과 표준편차를 기준으로 한 상한선, 하한선 밴드
</aside>

<aside>
➕

**TechnicalAnalysis 클래스의 세부 메서드**

- __init__(): 클래스 객체 초기화
- get_report(): 기술 분석 보고서 조회 및 생성
- get_rich_chart(): 차트 및 기술지표 데이터 조회
- get_technical_indicators(): 기술적 지표 계산
</aside>

<aside>
⚠️

**여기서 잠깐!**

- 메서드 정의 앞에 async를 추가하면 비동기 메서드를 정의할 수 있습니다.
- 이 프로젝트에서는 대시보드를 비동기 모드로 구동하여 데이터를 동시에 처리할 수 있게 하고자 합니다. 따라서 get_rich_chart()처럼 대시보드에서 직접 접근하는 메서드들은 비동기로 정의해야 합니다.
</aside>

### 3️⃣ 재무제표 데이터로 기본적 분석 수행하기 (FundamentalAnalysis)

- 이 클래스는 재무제표 원본, 재무 지표 데이터를 바탕으로 기업의 재무 상태를 분석하고, 분석 보고서를 생성합니다.
    - `_get_financials()`: 분석할 재무 데이터를 가져옵니다.
    - `get_indicators()`: kis 모듈을 활용해 재무 지표 데이터를 가져옵니다.
    - `get_report()`: 데이터를 종합해 기본 분석 보고서를 생성합니다.
    - `get_indicators_table_data()`: 대시보드에 표시할 재무지표 테이블 데이터를 반환합니다.
    - `get_indicators_graph_data()`: 대시보드에 표시할 재무지표 그래프 데이터를 반환합니다.

<aside>
➕

**주요 재무 지표 사이의 관계**

- ROE(return on equity, 자기자본이익률)
    - = (EPS / BPS) × 100 (%)
    - = (PBR / PER) × 100 (%)
- ROA(return on assets, 총 자산이익률)
    - = (순이익 / 총자산) × 100 (%)
    - = (순이익률) × (총 자산회전율)
</aside>

### 4️⃣ 뉴스 분석 보고서의 형식 지정하기 (NewsAnalysis)

- 뉴스 보고서를 위한 JSON 스키마를 정의합니다.

```python
news_format = {
    "type": "json_schema",
    "json_schema": {
        "name": "news_analysis",
        "strict": True,
        "schema": {
            "type": "object",
            "properties": {
                "articles": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "index": {"type": "integer"},
                            "title": {"type": "string"},
                            "reason": {"type": "string"},
                            "sentiment": {
                                "type": "string",
                                "enum": ["긍정 🌞", "부정 ⛈️", "중립 ⛅"],
                            },
                        },
                        "required": ["index", "title", "reason", "sentiment"],
                        "additionalProperties": False,
                    },
                },
                "overall_sentiment": {
                    "type": "integer"
                },
                "sentiment_emoji": {
                    "type": "string",
                    "enum": ["🟢", "🔴", "🟡"],
                },
            },
            "required": ["articles", "overall_sentiment", "sentiment_emoji"],
            "additionalProperties": False,
        },
    },
}

```

- AI는 스키마에서 각 옵션의 설명과 추가 프롬프트 텍스트에 따라, 대응하는 응답을 출력합니다.
    - `"strict": True` - 정확히 스키마에 맞는 형식으로만 응답하도록 강제합니다.
    - `"required": ["index", "title", "reason", "sentiment"]` - 필수 필드를 지정해 누락을 방지합니다.
    - `"additionalProperties": False` - 지정되지 않은 필드가 포함되지 않게 합니다.
    - `"enum": ["긍정 🌞", "부정 ⛈️", "중립 ⛅"]` - 특정 필드의 값을 미리 정의된 값으로 제한합니다.

### 5️⃣ 보고서 파일 관리하기 (ReportManager)

- ReportManager 클래스는 여러 보고서의 생성 시점과 업데이트 주기를 관리합니다.
    - JSON 설정 파일(analysis_settings.json)로 각 보고서 종류별 업데이트 주기를 관리합니다.

```json
{
    "fundamental": {
        "update_interval": {
            "days": 7,
            "description": "기본/재무 분석 보고서는 7일마다 갱신"
        }
    },
    "technical": {
        "min": {
            "update_interval": {
                "hours": 1,
                "description": "분봉 데이터는 1시간마다 갱신"
            }
        },
        "daily": {
            "update_interval": {
                "days": 1,
                "description": "일봉 데이터는 1일마다 갱신"
            }
        },
        "weekly": {
            "update_interval": {
                "days": 7,
                "description": "주봉 데이터는 7일마다 갱신"
            }
        }
    },
    "news": {
        "update_interval": {
            "hours": 6,
            "description": "뉴스 분석 보고서는 6시간마다 갱신"
        }
    }
}

```

- ReportManager 클래스의 객체는 각 보고서 생성 클래스에서 파일과 업데이트 시점을 관리하는 역할을 합니다.

```python
class TechnicalAnalysis:
    def __init__(self):
    ...
				self.report_manager = ReportManager(
				    report_root=project_root / "report",
				    report_type="fundamental",  # 폴더 구분용
				    settings=settings["fundamental"],  # update_interval이 들어있는 딕셔너리
				)
		...
		
		...
				
		async def get_report(self):
		    self,
        market: str,
        stock_code: str,
        overwrite=False,
        freq="daily",
        extra_prompt="",
    ) -> str:
        # 1. 최신 리포트 파일 확인
        latest_report = self.report_manager.get_latest_report(market, stock_code)

        if latest_report:
            latest_time, latest_file = latest_report
            if not overwrite and not self.report_manager.is_update_required(
                latest_time
            ):
                return latest_file.read_text(encoding="utf-8")
            else:
                print(f"[업데이트 필요] {stock_code} 기술적 분석 리포트 갱신 중...")

        else:
            print(f"[신규 생성] {stock_code} 기술적 분석 리포트 생성 중...")
        
        ...
```

<aside>
➕

**보고서 업데이트 기준 정하기**

- 보고서 종류와 데이터 특성, 개인의 선호에 따라 적절한 업데이트 주기를 설정할 수 있습니다.
    - 기본적 분석: 주로 분기별 재무제표에 의존하므로 상대적으로 긴 주기(7일)
    - 기술적 분석: 일일 가격 변동이 중요하므로 짧은 주기(1일)
    - 뉴스 분석: 시장 반응에 민감하므로 더 짧은 주기(6시간)
- 이를 통해 불필요한 API 호출과 비용을 절감하면서도 최신 정보를 유지할 수 있습니다.
</aside>