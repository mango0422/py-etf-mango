// kis/env.py
from __future__ import annotations

import os
from pathlib import Path
from typing import Optional

import requests
from dotenv import load_dotenv

PROJECT_ROOT = Path(__file__).resolve().parent.parent
DATA_DIR = PROJECT_ROOT / "data"
DATA_DIR.mkdir(parents=True, exist_ok=True)

RAW_MST_DIR = PROJECT_ROOT / "mst_raw"
OUT_DIR = PROJECT_ROOT / "mst_fixed"
OUT_DIR.mkdir(parents=True, exist_ok=True)

load_dotenv(PROJECT_ROOT / ".env")

KIS_URL_BASE: Optional[str] = os.getenv("KIS_URL_BASE")
KIS_APP_KEY: Optional[str] = os.getenv("KIS_APP_KEY")
KIS_APP_SECRET: Optional[str] = os.getenv("KIS_APP_SECRET")
KIS_ACCESS_TOKEN: Optional[str] = os.getenv("KIS_ACCESS_TOKEN")

def to_float(value) -> Optional[float]:
    try:
        return float(str(value).replace(",", "").strip())
    except Exception:
        return None



def get_api_headers(tr_id: str) -> dict[str, str]:
    from .env import KIS_ACCESS_TOKEN  # ì „ì—­ ì°¸ì¡°

    auth = f"Bearer {KIS_ACCESS_TOKEN}" if KIS_ACCESS_TOKEN else ""
    return {
        "content-type": "application/json; charset=utf-8",
        "authorization": auth,
        "appkey": KIS_APP_KEY or "",
        "appsecret": KIS_APP_SECRET or "",
        "tr_id": tr_id,
        "custtype": "P",
    }


def refresh_access_token() -> Optional[str]:
    global KIS_ACCESS_TOKEN

    if not KIS_URL_BASE:
        raise RuntimeError("KIS_URL_BASE ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤.")

    token_url = f"{KIS_URL_BASE}/oauth2/tokenP"

    headers = {
        "content-type": "application/json"
    }

    body = {
        "grant_type": "client_credentials",
        "appkey": KIS_APP_KEY,
        "appsecret": KIS_APP_SECRET
    }

    try:
        response = requests.post(token_url, headers=headers, json=body, timeout=5)
        data = response.json()

        if response.status_code == 200 and data.get("access_token"):
            new_token = data["access_token"]
            expires_in = data.get("expires_in", 86400)
            expired_at = data.get("access_token_token_expired", "")

            print(f"âœ… í† í° ì¬ë°œê¸‰ ì„±ê³µ")
            if expired_at:
                print(f"   ë§Œë£Œ ì‹œê°: {expired_at}")
            print(f"   ìœ íš¨ ì‹œê°„: {expires_in}ì´ˆ ({expires_in/3600:.1f}ì‹œê°„)")

            KIS_ACCESS_TOKEN = new_token

            try:
                env_path = PROJECT_ROOT / ".env"
                if env_path.exists():
                    lines = env_path.read_text(encoding="utf-8").split("\n")
                    new_lines = []
                    token_updated = False

                    for line in lines:
                        if line.startswith("KIS_ACCESS_TOKEN="):
                            new_lines.append(f"KIS_ACCESS_TOKEN={new_token}")
                            token_updated = True
                        else:
                            new_lines.append(line)

                    if not token_updated:
                        new_lines.append(f"KIS_ACCESS_TOKEN={new_token}")

                    env_path.write_text("\n".join(new_lines), encoding="utf-8")
                    print("   ğŸ“ .env íŒŒì¼ ì—…ë°ì´íŠ¸ ì™„ë£Œ")
            except Exception as e:
                print(f"   âš ï¸ .env íŒŒì¼ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (ë¬´ì‹œ ê°€ëŠ¥): {e}")

            return new_token
        else:
            print(f"âŒ í† í° ë°œê¸‰ ì‹¤íŒ¨: {data}")
            return None

    except Exception as e:
        print(f"âŒ í† í° ë°œê¸‰ ì¤‘ ì˜¤ë¥˜: {e}")
        return None


def validate_and_refresh_token() -> Optional[str]:
    global KIS_ACCESS_TOKEN

    if not KIS_URL_BASE:
        raise RuntimeError("KIS_URL_BASE ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤.")


    if not KIS_ACCESS_TOKEN:
        print("âš ï¸ ë©”ëª¨ë¦¬ì— í† í°ì´ ì—†ì–´ ì¬ë°œê¸‰ì„ ì‹œë„í•©ë‹ˆë‹¤.")
        return refresh_access_token()

    test_url = f"{KIS_URL_BASE}/uapi/etfetn/v1/quotations/inquire-price"
    test_params = {"FID_COND_MRKT_DIV_CODE": "J", "FID_INPUT_ISCD": "069500"}
    test_headers = get_api_headers("FHPST02400000")

    try:
        response = requests.get(test_url, headers=test_headers, params=test_params, timeout=5)
        data = response.json()

        if data.get("rt_cd") in ["EGW00123", "EGW00121"]:
            print("âš ï¸ í† í° ë§Œë£Œ ê°ì§€, ì¬ë°œê¸‰ ì‹œë„...")
            return refresh_access_token()
        elif data.get("rt_cd") == "0":
            print("âœ… ê¸°ì¡´ í† í° ìœ íš¨í•¨")
            return KIS_ACCESS_TOKEN
        else:
            print(f"âš ï¸ API ì‘ë‹µ ì˜¤ë¥˜ ({data.get('rt_cd')}), í† í° ì¬ë°œê¸‰ ì‹œë„...")
            return refresh_access_token()

    except requests.exceptions.Timeout:
        print("âš ï¸ API ì‘ë‹µ ì‹œê°„ ì´ˆê³¼ (ë„¤íŠ¸ì›Œí¬ ì´ìŠˆì¼ ìˆ˜ ìˆìŒ)")
        return KIS_ACCESS_TOKEN
    except Exception as e:
        print(f"âš ï¸ í† í° ê²€ì¦ ì¤‘ ì˜¤ë¥˜: {e}")
        return KIS_ACCESS_TOKEN


def ensure_kis_token() -> Optional[str]:
    token = validate_and_refresh_token()
    if not token:
        print("âŒ í† í° ë°œê¸‰/ê°±ì‹  ì‹¤íŒ¨ - KIS í™˜ê²½ë³€ìˆ˜(.env) ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.")
    return token


// kis/meta.py
from __future__ import annotations
from functools import lru_cache
from typing import Optional
import pandas as pd
import requests

from .env import OUT_DIR, validate_and_refresh_token, KIS_URL_BASE, get_api_headers

def _extract_6digit_code(s: str) -> Optional[str]:
    if not isinstance(s, str):
        return None
    digits = "".join(ch for ch in s if ch.isdigit())
    if len(digits) < 6:
        return None
    return digits[-6:]

def load_equity_master() -> pd.DataFrame:
    eq_path_parquet = OUT_DIR / "equity_master.parquet"
    eq_path_csv = OUT_DIR / "equity_master.csv"

    if eq_path_parquet.exists():
        df = pd.read_parquet(eq_path_parquet)
    elif eq_path_csv.exists():
        df = pd.read_csv(eq_path_csv)
    else:
        raise FileNotFoundError(
            f"equity_master íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {eq_path_parquet} / {eq_path_csv}"
        )

    if "name" in df.columns:
        df["name"] = df["name"].astype(str).str.strip()
    if "short_code" in df.columns:
        df["short_code"] = df["short_code"].astype(str).str.strip()
    if "std_code" in df.columns:
        df["std_code"] = df["std_code"].astype(str).str.strip()

    return df

def find_code_by_name(kor_name: str) -> pd.DataFrame:
    df = load_equity_master()
    m = df["name"].str.contains(kor_name, case=False, na=False)
    candidates = df[m].copy()

    if candidates.empty:
        print(f"âš ï¸ ì´ë¦„ì— '{kor_name}' ì´(ê°€) í¬í•¨ëœ ì¢…ëª©ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        return candidates

    if "kis_code" not in candidates.columns:
        if "short_code" in candidates.columns:
            candidates["kis_code"] = candidates["short_code"].apply(_extract_6digit_code)
        elif "std_code" in candidates.columns:
            candidates["kis_code"] = candidates["std_code"].apply(_extract_6digit_code)
        else:
            candidates["kis_code"] = None

    return candidates

def pick_single_code(kor_name: str) -> str:
    candidates = find_code_by_name(kor_name)
    if candidates.empty:
        raise ValueError(f"'{kor_name}' ì— í•´ë‹¹í•˜ëŠ” ì¢…ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    row = candidates.iloc[0]
    kis_code = row.get("kis_code")
    if not kis_code:
        raise ValueError(f"'{kor_name}' í›„ë³´ì—ì„œ KIS ì½”ë“œ(6ìë¦¬)ë¥¼ ì¶”ì¶œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n{row}")

    print(f"[INFO] '{kor_name}' â†’ ì„ íƒëœ ì¢…ëª©: {row.get('name')} (kis_code={kis_code})")
    return str(kis_code)

def get_etf_name_from_mst(etf_code: str) -> Optional[str]:
    df = load_equity_master()

    if "kis_code" not in df.columns:
        if "short_code" in df.columns:
            df["kis_code"] = df["short_code"].apply(_extract_6digit_code)
        elif "std_code" in df.columns:
            df["kis_code"] = df["std_code"].apply(_extract_6digit_code)

    if "kis_code" not in df.columns:
        return None

    m = df["kis_code"] == str(etf_code)
    hit = df[m]
    if hit.empty:
        return None

    name = str(hit.iloc[0]["name"]).strip()
    return name or None

def get_etf_name_from_kis(etf_code: str) -> Optional[str]:
    validate_and_refresh_token()
    if not KIS_URL_BASE:
        return None

    url = f"{KIS_URL_BASE}/uapi/domestic-stock/v1/quotations/search-stock-info"
    params = {"PRDT_TYPE_CD": "512", "PDNO": etf_code}
    headers = get_api_headers("CTPF1604R")

    try:
        res = requests.get(url, headers=headers, params=params, timeout=5)
        data = res.json()
    except Exception as e:
        print(f"âš ï¸ KIS ETF ì´ë¦„ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        return None

    if data.get("rt_cd") != "0" or not data.get("output"):
        return None

    output = data["output"]
    row = output[0] if isinstance(output, list) else output
    name = row.get("prdt_name") or row.get("hts_kor_isnm")
    name = (name or "").strip()
    return name or None

def get_etf_name(etf_code: str) -> str:
    code = str(etf_code)

    name = get_etf_name_from_mst(code)
    if name:
        print(f"âœ… ETF ì´ë¦„(MST): {code} â†’ {name}")
        return name

    name = get_etf_name_from_kis(code)
    if name:
        print(f"âœ… ETF ì´ë¦„(KIS): {code} â†’ {name}")
        return name

    print(f"âš ï¸ ETF ì´ë¦„ ì¡°íšŒ ì‹¤íŒ¨ â†’ ì½”ë“œ ì‚¬ìš© ({code})")
    return code
